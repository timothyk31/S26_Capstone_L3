[
  {
    "id": "openscap_001",
    "title": "Install AIDE",
    "description": "The aide package can be installed with the following command: $ sudo dnf install aide",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_aide_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_aide_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_002",
    "title": "Build and Test AIDE Database",
    "description": "Run the following command to generate a new database: $ sudo /usr/sbin/aide --init By default, the database will be written to the file /var/lib/aide/aide.db.new.gz. Storing the database, the configuration file /etc/aide.conf, and the binary /usr/sbin/aide (or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity. The newly-generated database can be installed as follows: $ sudo cp /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz To initiate a manual check, run the following command: $ sudo /usr/sbin/aide --check If this check produces any unexpected output, investigate.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_build_database",
    "rule": "xccdf_org.ssgproject.content_rule_aide_build_database",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi /usr/sbin/aide --init /bin/cp -p /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_003",
    "title": "Configure AIDE to Verify the Audit Tools",
    "description": "The operating system file integrity tool must be configured to protect the integrity of the audit tools.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_check_audit_tools",
    "rule": "xccdf_org.ssgproject.content_rule_aide_check_audit_tools",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi if grep -i -E '^.*(/usr)?/sbin/auditctl.*$' /etc/aide.conf; then sed -i -r \"s#.*(/usr)?/sbin/auditctl.*#/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide.conf else echo \"/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide.conf fi if grep -i -E '^.*(/usr)?/sbin/auditd.*$' /etc/aide.conf; then sed -i -r \"s#.*(/usr)?/sbin/auditd.*#/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide.conf else echo \"/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512\" >> /etc/aide.conf fi if grep -i -E '^.*(/usr)?/sbin/ausearch.*$' /etc/aide.conf; then sed -i -r \"s#.*(/usr)?/sbin/ausearch.*#/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs"
  },
  {
    "id": "openscap_004",
    "title": "Configure Notification of Post-AIDE Scan Details",
    "description": "AIDE should notify appropriate personnel of the details of a scan after the scan has been run. If AIDE has already been configured for periodic execution in /etc/crontab, append the following line to the existing AIDE line: | /bin/mail -s \"$(hostname) - AIDE Integrity Check\" root@localhost Otherwise, add the following line to /etc/crontab: 05 4 * * * root /usr/sbin/aide --check | /bin/mail -s \"$(hostname) - AIDE Integrity Check\" root@localhost AIDE can be executed periodically through other means; this is merely one example.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_scan_notification",
    "rule": "xccdf_org.ssgproject.content_rule_aide_scan_notification",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi var_aide_scan_notification_email='' CRONTAB=/etc/crontab CRONDIRS='/etc/cron.d /etc/cron.daily /etc/cron.weekly /etc/cron.monthly' # NOTE: on some platforms, /etc/crontab may not exist if [ -f /etc/crontab ]; then CRONTAB_EXIST=/etc/crontab fi if [ -f /var/spool/cron/root ]; then VARSPOOL=/var/spool/cron/root fi if ! grep -qR '^.*/usr/sbin/aide\\s*\\-\\-check.*|.*\\/bin\\/mail\\s*-s\\s*\".*\"\\s*.*@.*$' $CRONTAB_EXIST $VARSPOOL $CRONDIRS; then echo \"0 5 * * * root /usr/sbin/aide --check | /bin/mail -s \\\"\\$(hostname) - AIDE Integrity Check\\\" $var_aide_scan_notification_email\" >> $CRONTAB fi else >&2 echo 'Remediation is not applicable, nothing was done' "
  },
  {
    "id": "openscap_005",
    "title": "Configure AIDE to Use FIPS 140-2 for Validating Hashes",
    "description": "By default, the sha512 option is added to the NORMAL ruleset in AIDE. If using a custom ruleset or the sha512 option is missing, add sha512 to the appropriate ruleset. For example, add sha512 to the following line in /etc/aide.conf: NORMAL = FIPSR+sha512 AIDE rules can be configured in multiple ways; this is merely one example that is already configured by default.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_use_fips_hashes",
    "rule": "xccdf_org.ssgproject.content_rule_aide_use_fips_hashes",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi aide_conf=\"/etc/aide.conf\" forbidden_hashes=(sha1 rmd160 sha256 whirlpool tiger haval gost crc32) groups=$(LC_ALL=C grep \"^[A-Z][A-Za-z_]*\" $aide_conf | cut -f1 -d ' ' | tr -d ' ' | sort -u) for group in $groups do config=$(grep \"^$group\\s*=\" $aide_conf | cut -f2 -d '=' | tr -d ' ') if ! [[ $config = *sha512* ]] then config=$config\"+sha512\" fi for hash in \"${forbidden_hashes[@]}\" do config=$(echo $config | sed \"s/$hash//\") done config=$(echo $config | sed \"s/^\\+*//\") config=$(echo $config | sed \"s/\\+\\++/+/\") config=$(echo $config | sed \"s/\\+$//\") sed -i \"s/^$group\\s*=.*/$group = $config/g\" $aide_conf done else >&2 echo 'Remediation is not appl"
  },
  {
    "id": "openscap_006",
    "title": "Configure AIDE to Verify Access Control Lists (ACLs)",
    "description": "By default, the acl option is added to the FIPSR ruleset in AIDE. If using a custom ruleset or the acl option is missing, add acl to the appropriate ruleset. For example, add acl to the following line in /etc/aide.conf: FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256 AIDE rules can be configured in multiple ways; this is merely one example that is already configured by default. The remediation provided with this rule adds acl to all rule sets available in /etc/aide.conf",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_verify_acls",
    "rule": "xccdf_org.ssgproject.content_rule_aide_verify_acls",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi aide_conf=\"/etc/aide.conf\" groups=$(LC_ALL=C grep \"^[A-Z][A-Za-z_]*\" $aide_conf | grep -v \"^ALLXTRAHASHES\" | cut -f1 -d '=' | tr -d ' ' | sort -u) for group in $groups do config=$(grep \"^$group\\s*=\" $aide_conf | cut -f2 -d '=' | tr -d ' ') if ! [[ $config = *acl* ]] then if [[ -z $config ]] then config=\"acl\" else config=$config\"+acl\" fi fi sed -i \"s/^$group\\s*=.*/$group = $config/g\" $aide_conf done else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_007",
    "title": "Configure AIDE to Verify Extended Attributes",
    "description": "By default, the xattrs option is added to the FIPSR ruleset in AIDE. If using a custom ruleset or the xattrs option is missing, add xattrs to the appropriate ruleset. For example, add xattrs to the following line in /etc/aide.conf: FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256 AIDE rules can be configured in multiple ways; this is merely one example that is already configured by default. The remediation provided with this rule adds xattrs to all rule sets available in /etc/aide.conf",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_aide_verify_ext_attributes",
    "rule": "xccdf_org.ssgproject.content_rule_aide_verify_ext_attributes",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"aide\" ; then dnf install -y \"aide\" fi aide_conf=\"/etc/aide.conf\" groups=$(LC_ALL=C grep \"^[A-Z][A-Za-z_]*\" $aide_conf | grep -v \"^ALLXTRAHASHES\" | cut -f1 -d '=' | tr -d ' ' | sort -u) for group in $groups do config=$(grep \"^$group\\s*=\" $aide_conf | cut -f2 -d '=' | tr -d ' ') if ! [[ $config = *xattrs* ]] then if [[ -z $config ]] then config=\"xattrs\" else config=$config\"+xattrs\" fi fi sed -i \"s/^$group\\s*=.*/$group = $config/g\" $aide_conf done else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_008",
    "title": "Enable Dracut FIPS Module",
    "description": "Red Hat Enterprise Linux 9 has an installation-time kernel flag that can enable FIPS mode. The installer must be booted with fips=1 for the system to have FIPS mode enabled. Enabling FIPS mode on a preexisting system is not supported. If this rule fails on an installed system, then this is a permanent finding and cannot be fixed. To enable FIPS, the system requires that the fips module is added in dracut configuration. Check if /etc/dracut.conf.d/40-fips.conf contain add_dracutmodules+=\" fips \"",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_enable_dracut_fips_module",
    "rule": "xccdf_org.ssgproject.content_rule_enable_dracut_fips_module",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Enable Dracut FIPS Module"
  },
  {
    "id": "openscap_009",
    "title": "Enable FIPS Mode",
    "description": "Red Hat Enterprise Linux 9 has an installation-time kernel flag that can enable FIPS mode. The installer must be booted with fips=1 for the system to have FIPS mode enabled. Enabling FIPS mode on a preexisting system is not supported. If this rule fails on an installed system, then this is a permanent finding and cannot be fixed. To enable FIPS mode at bootable container build time configure fips=1 kernel argument in /usr/lib/bootc/kargs.d/01-fips.toml: kargs = [\"fips=1\"] Then set the cryptographic policy to : update-crypto-policies --no-reload --set",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_enable_fips_mode",
    "rule": "xccdf_org.ssgproject.content_rule_enable_fips_mode",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( [ \"${container:-}\" == \"bwrap-osbuild\" ] ) && rpm --quiet -q kernel-core ); then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; }; then cat > /usr/lib/bootc/kargs.d/01-fips.toml << EOF kargs = [\"fips=1\"] EOF fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_010",
    "title": "FIPS Must Use a Supported Subpolicy",
    "description": "Sub-policies can be used to modify existing crypto policies. Some sub-policies such as NO-ENFORCE-EMS reduce the security of the system and should not be used. Other such as AD-SUPPORT should only be enabled if operationally required. The OSPP, NO-SHA1, NO-CAMELLIA, and ECDHE-ONLY are allowed by this rule.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_fips_crypto_subpolicy",
    "rule": "xccdf_org.ssgproject.content_rule_fips_crypto_subpolicy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: FIPS Must Use a Supported Subpolicy"
  },
  {
    "id": "openscap_011",
    "title": "Implement STIG Sub Crypto Policy",
    "description": "Create a custom cryptographic policy to follow the guidance from DISA.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_fips_custom_stig_sub_policy",
    "rule": "xccdf_org.ssgproject.content_rule_fips_custom_stig_sub_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: cat << 'EOF' > /etc/crypto-policies/policies/modules/STIG.pmod cipher@SSH=AES-256-GCM AES-256-CTR AES-128-GCM AES-128-CTR mac@SSH=HMAC-SHA2-512 HMAC-SHA2-256 EOF sudo update-crypto-policies --set FIPS:STIG"
  },
  {
    "id": "openscap_012",
    "title": "Set kernel parameter 'crypto.fips_enabled' to 1",
    "description": "System running in FIPS mode is indicated by kernel parameter 'crypto.fips_enabled'. This parameter should be set to 1 in FIPS mode. Red Hat Enterprise Linux 9 has an installation-time kernel flag that can enable FIPS mode. The installer must be booted with fips=1 for the system to have FIPS mode enabled. Enabling FIPS mode on a preexisting system is not supported. If this rule fails on an installed system, then this is a permanent finding and cannot be fixed. To enable strict FIPS compliance, the fips=1 kernel option needs to be added to the kernel boot parameters during system installation so key generation is done with FIPS-approved algorithms and continuous monitoring tests in place.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_crypto_fips_enabled",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_crypto_fips_enabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Set kernel parameter 'crypto.fips_enabled' to 1"
  },
  {
    "id": "openscap_013",
    "title": "Configure System Cryptography Policy",
    "description": "To configure the system cryptography policy to use ciphers only from the policy, run the following command: $ sudo update-crypto-policies --set The rule checks if settings for selected crypto policy are configured as expected. Configuration files in the /etc/crypto-policies/back-ends are either symlinks to correct files provided by Crypto-policies package or they are regular files in case crypto policy customizations are applied. Crypto policies may be customized by crypto policy modules, in which case it is delimited from the base policy using a colon.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_configure_crypto_policy",
    "rule": "xccdf_org.ssgproject.content_rule_configure_crypto_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: var_system_crypto_policy='' stderr_of_call=$(update-crypto-policies --set ${var_system_crypto_policy} 2>&1 > /dev/null) rc=$? if test \"$rc\" = 127; then echo \"$stderr_of_call\" >&2 echo \"Make sure that the script is installed on the remediated system.\" >&2 echo \"See output of the 'dnf provides update-crypto-policies' command\" >&2 echo \"to see what package to (re)install\" >&2 false # end with an error code elif test \"$rc\" != 0; then echo \"Error invoking the update-crypto-policies script: $stderr_of_call\" >&2 false # end with an error code fi"
  },
  {
    "id": "openscap_014",
    "title": "Configure SSH Client to Use FIPS 140 Validated Ciphers: openssh.config",
    "description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages. OpenSSH is supported by system crypto policy, but the OpenSSH configuration may be set up incorrectly. To check that Crypto Policies settings for ciphers are configured correctly, ensure that /etc/crypto-policies/back-ends/openssh.config contains the following line and is not commented out: Ciphers",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_harden_sshd_ciphers_openssh_conf_crypto_policy",
    "rule": "xccdf_org.ssgproject.content_rule_harden_sshd_ciphers_openssh_conf_crypto_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Configure SSH Client to Use FIPS 140 Validated Ciphers: openssh.config"
  },
  {
    "id": "openscap_015",
    "title": "Configure SSH Server to Use FIPS 140-2 Validated Ciphers: opensshserver.config",
    "description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages. OpenSSH is supported by system crypto policy, but the OpenSSH configuration may be set up incorrectly. To check that Crypto Policies settings for ciphers are configured correctly, ensure that /etc/crypto-policies/back-ends/opensshserver.config contains the following text and is not commented out: -oCiphers=",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_harden_sshd_ciphers_opensshserver_conf_crypto_policy",
    "rule": "xccdf_org.ssgproject.content_rule_harden_sshd_ciphers_opensshserver_conf_crypto_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Configure SSH Server to Use FIPS 140-2 Validated Ciphers: opensshserver.config"
  },
  {
    "id": "openscap_016",
    "title": "Configure SSH Client to Use FIPS 140-2 Validated MACs: openssh.config",
    "description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages. OpenSSH is supported by system crypto policy, but the OpenSSH configuration may be set up incorrectly. To check that Crypto Policies settings are configured correctly, ensure that /etc/crypto-policies/back-ends/openssh.config contains the following line and is not commented out: MACs",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_harden_sshd_macs_openssh_conf_crypto_policy",
    "rule": "xccdf_org.ssgproject.content_rule_harden_sshd_macs_openssh_conf_crypto_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Configure SSH Client to Use FIPS 140-2 Validated MACs: openssh.config"
  },
  {
    "id": "openscap_017",
    "title": "Configure SSH Server to Use FIPS 140-2 Validated MACs: opensshserver.config",
    "description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages. OpenSSH is supported by system crypto policy, but the OpenSSH configuration may be set up incorrectly. To check that Crypto Policies settings are configured correctly, ensure that /etc/crypto-policies/back-ends/opensshserver.config contains the following text and is not commented out: -oMACS=",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_harden_sshd_macs_opensshserver_conf_crypto_policy",
    "rule": "xccdf_org.ssgproject.content_rule_harden_sshd_macs_opensshserver_conf_crypto_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Configure SSH Server to Use FIPS 140-2 Validated MACs: opensshserver.config"
  },
  {
    "id": "openscap_018",
    "title": "The Installed Operating System Is Vendor Supported",
    "description": "The installed operating system must be maintained by a vendor. Red Hat Enterprise Linux is supported by Red Hat, Inc. As the Red Hat Enterprise Linux vendor, Red Hat, Inc. is responsible for providing security patches.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_installed_OS_is_vendor_supported",
    "rule": "xccdf_org.ssgproject.content_rule_installed_OS_is_vendor_supported",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: The Installed Operating System Is Vendor Supported"
  },
  {
    "id": "openscap_019",
    "title": "Ensure /home Located On Separate Partition",
    "description": "If user home directories will be stored locally, create a separate partition for /home at installation time (or migrate it later using LVM). If /home will be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint can instead be configured later.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_home",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_home",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /home"
  },
  {
    "id": "openscap_020",
    "title": "Ensure /tmp Located On Separate Partition",
    "description": "The /tmp directory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_tmp",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_tmp",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /tmp"
  },
  {
    "id": "openscap_021",
    "title": "Ensure /var Located On Separate Partition",
    "description": "The /var directory is used by daemons and other system services to store frequently-changing data. Ensure that /var has its own partition or logical volume at installation time, or migrate it using LVM.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_var",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_var",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /var"
  },
  {
    "id": "openscap_022",
    "title": "Ensure /var/log Located On Separate Partition",
    "description": "System logs are stored in the /var/log directory. Ensure that /var/log has its own partition or logical volume at installation time, or migrate it using LVM.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_var_log",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_var_log",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /var/log"
  },
  {
    "id": "openscap_023",
    "title": "Ensure /var/log/audit Located On Separate Partition",
    "description": "Audit logs are stored in the /var/log/audit directory. Ensure that /var/log/audit has its own partition or logical volume at installation time, or migrate it using LVM. Make absolutely certain that it is large enough to store all audit logs that will be created by the auditing daemon.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_var_log_audit",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_var_log_audit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /var/log/audit"
  },
  {
    "id": "openscap_024",
    "title": "Ensure /var/tmp Located On Separate Partition",
    "description": "The /var/tmp directory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_partition_for_var_tmp",
    "rule": "xccdf_org.ssgproject.content_rule_partition_for_var_tmp",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: part /var/tmp"
  },
  {
    "id": "openscap_025",
    "title": "Require Re-Authentication When Using the sudo Command",
    "description": "The sudo timestamp_timeout tag sets the amount of time sudo password prompt waits. The default timestamp_timeout value is 5 minutes. The timestamp_timeout should be configured by making sure that the timestamp_timeout tag exists in /etc/sudoers configuration file or any sudo configuration snippets in /etc/sudoers.d/. If the value is set to an integer less than 0, the user's time stamp will not expire and the user will not have to re-authenticate for privileged actions until the user's session is terminated.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sudo_require_reauthentication",
    "rule": "xccdf_org.ssgproject.content_rule_sudo_require_reauthentication",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q sudo; }; then var_sudo_timestamp_timeout='' if grep -Px '^[\\s]*Defaults.*timestamp_timeout[\\s]*=.*' /etc/sudoers.d/*; then find /etc/sudoers.d/ -type f -exec sed -Ei \"/^[[:blank:]]*Defaults.*timestamp_timeout[[:blank:]]*=.*/d\" {} \\; fi if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*timestamp_timeout[\\s]*=[\\s]*[-]?\\w+.*$' /etc/sudoers; then # sudoers file doesn't define Option timestamp_timeout echo \"Defaults timestamp_timeout=${var_sudo_timestamp_timeout}\" >> /etc/sudoers else # sudoers file defines Option timestamp_timeout, remediate wrong values if present if grep -qP \"^[\\s]*Defaults\\s.*\\btimestamp_timeout[\\s]*=[\\s]*(?!${var_s"
  },
  {
    "id": "openscap_026",
    "title": "Ensure invoking users password for privilege escalation when using sudo",
    "description": "The sudoers security policy requires that users authenticate themselves before they can use sudo. When sudoers requires authentication, it validates the invoking user's credentials. The expected output for: sudo cvtsudoers -f sudoers /etc/sudoers | grep -E '^Defaults !?(rootpw|targetpw|runaspw)$' Defaults !targetpw Defaults !rootpw Defaults !runaspw or if cvtsudoers not supported: sudo find /etc/sudoers /etc/sudoers.d \\( \\! -name '*~' -a \\! -name '*.*' \\) -exec grep -E --with-filename '^[[:blank:]]*Defaults[[:blank:]](.*[[:blank:]])?!?\\b(rootpw|targetpw|runaspw)' -- {} \\; /etc/sudoers:Defaults !targetpw /etc/sudoers:Defaults !rootpw /etc/sudoers:Defaults !runaspw",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sudoers_validate_passwd",
    "rule": "xccdf_org.ssgproject.content_rule_sudoers_validate_passwd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q sudo; }; then if grep -x '^Defaults targetpw$' /etc/sudoers; then sed -i \"/Defaults targetpw/d\" /etc/sudoers \\; fi if grep -x '^Defaults targetpw$' /etc/sudoers.d/*; then find /etc/sudoers.d/ -type f -exec sed -i \"/Defaults targetpw/d\" {} \\; fi if grep -x '^Defaults rootpw$' /etc/sudoers; then sed -i \"/Defaults rootpw/d\" /etc/sudoers \\; fi if grep -x '^Defaults rootpw$' /etc/sudoers.d/*; then find /etc/sudoers.d/ -type f -exec sed -i \"/Defaults rootpw/d\" {} \\; fi if grep -x '^Defaults runaspw$' /etc/sudoers; then sed -i \"/Defaults runaspw/d\" /etc/sudoers \\; fi if grep -x '^Defaults runaspw$' /etc/sudoers.d/*; then find /etc/sudoers.d/ -type f -exec sed -i \"/Defaults runaspw/d\" {} \\; fi i"
  },
  {
    "id": "openscap_027",
    "title": "Ensure gnutls-utils is installed",
    "description": "The gnutls-utils package can be installed with the following command: $ sudo dnf install gnutls-utils",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_gnutls-utils_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_gnutls-utils_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: if ! rpm -q --quiet \"gnutls-utils\" ; then dnf install -y \"gnutls-utils\" fi"
  },
  {
    "id": "openscap_028",
    "title": "Ensure nss-tools is installed",
    "description": "The nss-tools package can be installed with the following command: $ sudo dnf install nss-tools",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_nss-tools_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_nss-tools_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: if ! rpm -q --quiet \"nss-tools\" ; then dnf install -y \"nss-tools\" fi"
  },
  {
    "id": "openscap_029",
    "title": "Install rng-tools Package",
    "description": "The rng-tools package can be installed with the following command: $ sudo dnf install rng-tools",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_rng-tools_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_rng-tools_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( [ \"$(sysctl -a | grep -c 'fips_enabled.*1')\" -eq 1 ] ) && rpm --quiet -q kernel-core ); then if ! rpm -q --quiet \"rng-tools\" ; then dnf install -y \"rng-tools\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_030",
    "title": "Install subscription-manager Package",
    "description": "The subscription-manager package can be installed with the following command: $ sudo dnf install subscription-manager",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_subscription-manager_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_subscription-manager_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: if ! rpm -q --quiet \"subscription-manager\" ; then dnf install -y \"subscription-manager\" fi"
  },
  {
    "id": "openscap_031",
    "title": "Uninstall iprutils Package",
    "description": "The iprutils package can be removed with the following command: $ sudo dnf remove iprutils",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_iprutils_removed",
    "rule": "xccdf_org.ssgproject.content_rule_package_iprutils_removed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # CAUTION: This remediation script will remove iprutils # from the system, and may remove any packages # that depend on iprutils. Execute this # remediation AFTER testing on a non-production # system! if rpm -q --quiet \"iprutils\" ; then dnf remove -y --noautoremove \"iprutils\" fi"
  },
  {
    "id": "openscap_032",
    "title": "Uninstall tuned Package",
    "description": "The tuned package can be removed with the following command: $ sudo dnf remove tuned",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_tuned_removed",
    "rule": "xccdf_org.ssgproject.content_rule_package_tuned_removed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # CAUTION: This remediation script will remove tuned # from the system, and may remove any packages # that depend on tuned. Execute this # remediation AFTER testing on a non-production # system! if rpm -q --quiet \"tuned\" ; then dnf remove -y --noautoremove \"tuned\" fi"
  },
  {
    "id": "openscap_033",
    "title": "Ensure gpgcheck Enabled for Local Packages",
    "description": "dnf should be configured to verify the signature(s) of local packages prior to installation. To configure dnf to verify signatures of local packages, set the localpkg_gpgcheck to 1 in /etc/dnf/dnf.conf.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_ensure_gpgcheck_local_packages",
    "rule": "xccdf_org.ssgproject.content_rule_ensure_gpgcheck_local_packages",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q dnf; then # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^localpkg_gpgcheck\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^localpkg_gpgcheck\\\\>\" \"/etc/dnf/dnf.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --follow-symlinks \"s/^localpkg_gpgcheck\\\\>.*/$escaped_formatte"
  },
  {
    "id": "openscap_034",
    "title": "Enable authselect",
    "description": "Configure user authentication setup to use the authselect tool. If authselect profile is selected, the rule will enable the profile.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_enable_authselect",
    "rule": "xccdf_org.ssgproject.content_rule_enable_authselect",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_authselect_profile='' authselect current if test \"$?\" -ne 0; then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; }; then authselect select --force \"$var_authselect_profile\" else authselect select \"$var_authselect_profile\" fi if test \"$?\" -ne 0; then if rpm --quiet --verify pam; then authselect select --force \"$var_authselect_profile\" else echo \"authselect is not used but files from the 'pam' package have been altered, so the authselect configuration won't be forced.\" >&2 fi fi fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_035",
    "title": "Modify the System Login Banner",
    "description": "To configure the system login banner edit /etc/issue. Replace the default text with a message compliant with the local site policy or a legal disclaimer. The DoD required text is either: You are accessing a U.S. Government (USG) Information System (IS) that is provided for USG-authorized use only. By using this IS (which includes any device attached to this IS), you consent to the following conditions: -The USG routinely intercepts and monitors communications on this IS for purposes including, but not limited to, penetration testing, COMSEC monitoring, network operations and defense, personnel misconduct (PM), law enforcement (LE), and counterintelligence (CI) investigations. -At any time, the USG may inspect and seize data stored on this IS. -Communications using, or data stored on, this IS are not private, are subject to routine monitoring, interception, and search, and may be disclosed or used for any USG-authorized purpose. -This IS includes security measures (e.g., authentication and access controls) to protect USG interests -- not for your personal benefit or privacy. -Notwithstanding the above, using this IS does not constitute consent to PM, LE or CI investigative searching or monitoring of the content of privileged communications, or work product, related to personal representation or services by attorneys, psychotherapists, or clergy, and their assistants. Such communications and work product are private and confidential. See User Agreement for details. OR: I've read & consent to terms in IS user agreem't.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_banner_etc_issue",
    "rule": "xccdf_org.ssgproject.content_rule_banner_etc_issue",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then login_banner_text='' # Multiple regexes transform the banner regex into a usable banner # 0 - Remove anchors around the banner text login_banner_text=$(echo \"$login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g') # 1 - Keep only the first banners if there are multiple # (dod_banners contains the long and short banner) login_banner_text=$(echo \"$login_banner_text\" | sed 's/^(\\(.*\\.\\)|.*)$/\\1/g') # 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \") login_banner_text=$(echo \"$login_banner_text\" | sed 's/\\[\\\\s\\\\n\\]+/ /g') # 3 - Adds newlines. (Transforms \"(?:\\[\\\\n\\]+|(?:\\\\n)+)\" into \"\\n\") login_banner_text=$(echo \"$login_banner_text\" | sed 's/(?:\\[\\\\n\\]+|(?:\\\\\\\\n)+)/\\n/g') # 4 - Remove any"
  },
  {
    "id": "openscap_036",
    "title": "Configure the Use of the pam_faillock.so Module in the /etc/pam.d/password-auth File.",
    "description": "The pam_faillock.so module must be loaded in preauth in /etc/pam.d/password-auth.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_account_password_pam_faillock_password_auth",
    "rule": "xccdf_org.ssgproject.content_rule_account_password_pam_faillock_password_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FILES[@]}\" do if ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+(pre"
  },
  {
    "id": "openscap_037",
    "title": "Configure the Use of the pam_faillock.so Module in the /etc/pam.d/system-auth File.",
    "description": "The pam_faillock.so module must be loaded in preauth in /etc/pam.d/system-auth.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_account_password_pam_faillock_system_auth",
    "rule": "xccdf_org.ssgproject.content_rule_account_password_pam_faillock_system_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FILES[@]}\" do if ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+(pre"
  },
  {
    "id": "openscap_038",
    "title": "Account Lockouts Must Be Logged",
    "description": "PAM faillock locks an account due to excessive password failures, this event must be logged.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_audit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FILES[@]}\" do if ! grep -qE '^\\s*auth\\s+require"
  },
  {
    "id": "openscap_039",
    "title": "Lock Accounts After Failed Password Attempts",
    "description": "This rule configures the system to lock out accounts after a number of incorrect login attempts using pam_faillock.so. pam_faillock.so module requires multiple entries in pam files. These entries must be carefully defined to work as expected. Ensure that the file /etc/security/faillock.conf contains the following entry: deny = <count> Where count should be less than or equal to and greater than 0. In order to avoid errors when manually editing these files, it is recommended to use the appropriate tools, such as authselect or authconfig, depending on the OS version.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then var_accounts_passwords_pam_faillock_deny='' if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FIL"
  },
  {
    "id": "openscap_040",
    "title": "Configure the root Account for Failed Password Attempts",
    "description": "This rule configures the system to lock out the root account after a number of incorrect login attempts using pam_faillock.so. pam_faillock.so module requires multiple entries in pam files. These entries must be carefully defined to work as expected. In order to avoid errors when manually editing these files, it is recommended to use the appropriate tools, such as authselect or authconfig, depending on the OS version.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny_root",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny_root",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FILES[@]}\" do if ! grep -qE '^\\s*auth\\s+require"
  },
  {
    "id": "openscap_041",
    "title": "Lock Accounts Must Persist",
    "description": "This rule ensures that the system lock out accounts using pam_faillock.so persist after system reboot. From \"pam_faillock\" man pages: Note that the default directory that \"pam_faillock\" uses is usually cleared on system boot so the access will be re-enabled after system reboot. If that is undesirable, a different tally directory must be set with the \"dir\" option. pam_faillock.so module requires multiple entries in pam files. These entries must be carefully defined to work as expected. In order to avoid errors when manually editing these files, it is recommended to use the appropriate tools, such as authselect or authconfig, depending on the OS version. The chosen profile expects the directory to be . To configure the tally directory, add the following line to /etc/security/faillock.conf: dir =",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_dir",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_dir",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then var_accounts_passwords_pam_faillock_dir='' if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${AUTH_FILE"
  },
  {
    "id": "openscap_042",
    "title": "Set Interval For Counting Failed Password Attempts",
    "description": "Utilizing pam_faillock.so, the fail_interval directive configures the system to lock out an account after a number of incorrect login attempts within a specified time period. Ensure that the file /etc/security/faillock.conf contains the following entry: fail_interval = <interval-in-seconds> where interval-in-seconds is or greater. In order to avoid errors when manually editing these files, it is recommended to use the appropriate tools, such as authselect or authconfig, depending on the OS version.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_interval",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then var_accounts_passwords_pam_faillock_fail_interval='' if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"$"
  },
  {
    "id": "openscap_043",
    "title": "Set Lockout Time for Failed Password Attempts",
    "description": "This rule configures the system to lock out accounts during a specified time period after a number of incorrect login attempts using pam_faillock.so. Ensure that the file /etc/security/faillock.conf contains the following entry: unlock_time=<interval-in-seconds> where interval-in-seconds is or greater. pam_faillock.so module requires multiple entries in pam files. These entries must be carefully defined to work as expected. In order to avoid any errors when manually editing these files, it is recommended to use the appropriate tools, such as authselect or authconfig, depending on the OS version. If unlock_time is set to 0, manual intervention by an administrator is required to unlock a user. This should be done using the faillock tool.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then var_accounts_passwords_pam_faillock_unlock_time='' if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature with-faillock authselect apply-changes -b else AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\") for pam_file in \"${A"
  },
  {
    "id": "openscap_044",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Digit Characters",
    "description": "The pam_pwquality module's dcredit parameter controls requirements for usage of digits in a password. When set to a negative number, any password will be required to contain that many digits. When set to a positive number, pam_pwquality will grant +1 additional length credit for each digit. Modify the dcredit setting in /etc/security/pwquality.conf to require the use of a digit in passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_dcredit='' if grep -sq dcredit /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/dcredit/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -"
  },
  {
    "id": "openscap_045",
    "title": "Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words",
    "description": "The pam_pwquality module's dictcheck check if passwords contains dictionary words. When dictcheck is set to 1 passwords will be checked for dictionary words.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dictcheck",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_dictcheck='' if grep -sq dictcheck /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/dictcheck/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dictcheck\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dictcheck\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_AL"
  },
  {
    "id": "openscap_046",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Different Characters",
    "description": "The pam_pwquality module's difok parameter sets the number of characters in a password that must not be present in and old password during a password change. Modify the difok setting in /etc/security/pwquality.conf to equal to require differing characters when changing passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_difok",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_difok",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_difok='' if grep -sq difok /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/difok/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^difok\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_difok\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i "
  },
  {
    "id": "openscap_047",
    "title": "Ensure PAM Enforces Password Requirements - Enforce for root User",
    "description": "The pam_pwquality module's enforce_for_root parameter controls requirements for enforcing password complexity for the root user. Enable the enforce_for_root setting in /etc/security/pwquality.conf to require the root user to use complex passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_enforce_root",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_enforce_root",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then if [ -e \"/etc/security/pwquality.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*enforce_for_root/Id\" \"/etc/security/pwquality.conf\" else touch \"/etc/security/pwquality.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/security/pwquality.conf\" cp \"/etc/security/pwquality.conf\" \"/etc/security/pwquality.conf.bak\" # Insert at the end of the file printf '%s\\n' \"enforce_for_root\" >> \"/etc/security/pwquality.conf\" # Clean up after ourselves. rm \"/etc/security/pwquality.conf.bak\" else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_048",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters",
    "description": "The pam_pwquality module's lcredit parameter controls requirements for usage of lowercase letters in a password. When set to a negative number, any password will be required to contain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each lowercase character. Modify the lcredit setting in /etc/security/pwquality.conf to require the use of a lowercase character in passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_lcredit='' if grep -sq lcredit /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/lcredit/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^lcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -"
  },
  {
    "id": "openscap_049",
    "title": "Ensure PAM Enforces Password Requirements - Maximum Consecutive Repeating Characters from Same Character Class",
    "description": "The pam_pwquality module's maxclassrepeat parameter controls requirements for consecutive repeating characters from the same character class. When set to a positive number, it will reject passwords which contain more than that number of consecutive characters from the same character class. Modify the maxclassrepeat setting in /etc/security/pwquality.conf to equal to prevent a run of ( + 1) or more identical characters.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_maxclassrepeat",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_maxclassrepeat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_maxclassrepeat='' if grep -sq maxclassrepeat /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/maxclassrepeat/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^maxclassrepeat\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_maxclassrepeat\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'settin"
  },
  {
    "id": "openscap_050",
    "title": "Set Password Maximum Consecutive Repeating Characters",
    "description": "The pam_pwquality module's maxrepeat parameter controls requirements for consecutive repeating characters. When set to a positive number, it will reject passwords which contain more than that number of consecutive characters. Modify the maxrepeat setting in /etc/security/pwquality.conf to equal to prevent a run of ( + 1) or more identical characters.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_maxrepeat",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_maxrepeat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_maxrepeat='' if grep -sq maxrepeat /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/maxrepeat/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^maxrepeat\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_maxrepeat\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_AL"
  },
  {
    "id": "openscap_051",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Different Categories",
    "description": "The pam_pwquality module's minclass parameter controls requirements for usage of different character classes, or types, of character that must exist in a password before it is considered valid. For example, setting this value to three (3) requires that any password must have characters from at least three different categories in order to be approved. The default value is zero (0), meaning there are no required classes. There are four categories available: * Upper-case characters * Lower-case characters * Digits * Special characters (for example, punctuation) Modify the minclass setting in /etc/security/pwquality.conf entry to require differing categories of characters when changing passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minclass",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minclass",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_minclass='' if grep -sq minclass /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/minclass/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^minclass\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minclass\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C g"
  },
  {
    "id": "openscap_052",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Length",
    "description": "The pam_pwquality module's minlen parameter controls requirements for minimum characters required in a password. Add minlen= after pam_pwquality to set minimum password length requirements.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_minlen='' if grep -sq minlen /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/minlen/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^minlen\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m "
  },
  {
    "id": "openscap_053",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Special Characters",
    "description": "The pam_pwquality module's ocredit= parameter controls requirements for usage of special (or \"other\") characters in a password. When set to a negative number, any password will be required to contain that many special characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each special character. Modify the ocredit setting in /etc/security/pwquality.conf to equal to require use of a special character in passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ocredit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_ocredit='' if grep -sq ocredit /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/ocredit/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ocredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ocredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -"
  },
  {
    "id": "openscap_054",
    "title": "Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session in /etc/security/pwquality.conf",
    "description": "To configure the number of retry prompts that are permitted per-session: Edit the /etc/security/pwquality.conf to include retry= , or a lower value if site policy is more restrictive. The profile requirement is a maximum of retry= prompts per session.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_pwquality_retry",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_pwquality_retry",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_password_pam_retry='' if grep -sq retry /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/retry/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^retry\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_retry\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^retry\\\\>\" \"/etc/security/pwqual"
  },
  {
    "id": "openscap_055",
    "title": "Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters",
    "description": "The pam_pwquality module's ucredit= parameter controls requirements for usage of uppercase letters in a password. When set to a negative number, any password will be required to contain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each uppercase character. Modify the ucredit setting in /etc/security/pwquality.conf to require the use of an uppercase character in passwords.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q libpwquality; }; then var_password_pam_ucredit='' if grep -sq ucredit /etc/security/pwquality.conf.d/*.conf ; then sed -i \"/ucredit/d\" /etc/security/pwquality.conf.d/*.conf fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ucredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -"
  },
  {
    "id": "openscap_056",
    "title": "Disable debug-shell SystemD Service",
    "description": "SystemD's debug-shell service is intended to diagnose SystemD related boot issues with various systemctl commands. Once enabled and following a system reboot, the root shell will be available on tty9 which is access by pressing CTRL-ALT-F9. The debug-shell service should only be used for SystemD related issues and should otherwise be disabled. By default, the debug-shell SystemD service is already disabled. The debug-shell service can be disabled with the following command: $ sudo systemctl mask --now debug-shell.service",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_debug-shell_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_debug-shell_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then SYSTEMCTL_EXEC='/usr/bin/systemctl' if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" stop 'debug-shell.service' fi \"$SYSTEMCTL_EXEC\" disable 'debug-shell.service' \"$SYSTEMCTL_EXEC\" mask 'debug-shell.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" -q list-unit-files debug-shell.socket; then if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" stop 'debug-shell.socket' fi \"$SYSTEMCTL_EXEC\" mask 'debug-shell.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot tho"
  },
  {
    "id": "openscap_057",
    "title": "Disable Ctrl-Alt-Del Burst Action",
    "description": "By default, SystemD will reboot the system if the Ctrl-Alt-Del key sequence is pressed Ctrl-Alt-Delete more than 7 times in 2 seconds. To configure the system to ignore the CtrlAltDelBurstAction setting, add or modify the following to /etc/systemd/system.conf: CtrlAltDelBurstAction=none",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_burstaction",
    "rule": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_burstaction",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q systemd; }; then # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^CtrlAltDelBurstAction=\") # shellcheck disable=SC2059 printf -v formatted_output \"%s=%s\" \"$stripped_key\" \"none\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^CtrlAltDelBurstAction=\\\\>\" \"/etc/systemd/system.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --fol"
  },
  {
    "id": "openscap_058",
    "title": "Disable Ctrl-Alt-Del Reboot Activation",
    "description": "By default, SystemD will reboot the system if the Ctrl-Alt-Del key sequence is pressed. To configure the system to ignore the Ctrl-Alt-Del key sequence from the command line instead of rebooting the system, do either of the following: ln -sf /dev/null /etc/systemd/system/ctrl-alt-del.target or systemctl mask ctrl-alt-del.target Do not simply delete the /usr/lib/systemd/system/ctrl-alt-del.service file, as this file may be restored during future system updates.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot",
    "rule": "xccdf_org.ssgproject.content_rule_disable_ctrlaltdel_reboot",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then systemctl disable ctrl-alt-del.target systemctl mask ctrl-alt-del.target else systemctl disable --now ctrl-alt-del.target systemctl mask --now ctrl-alt-del.target fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_059",
    "title": "Install the opensc Package For Multifactor Authentication",
    "description": "The opensc package can be installed with the following command: $ sudo dnf install opensc",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_opensc_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_opensc_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"opensc\" ; then dnf install -y \"opensc\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_060",
    "title": "Install the pcsc-lite package",
    "description": "The pcsc-lite package can be installed with the following command: $ sudo dnf install pcsc-lite",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_pcsc-lite_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_pcsc-lite_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"pcsc-lite\" ; then dnf install -y \"pcsc-lite\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_061",
    "title": "Install Smart Card Packages For Multifactor Authentication",
    "description": "Configure the operating system to implement multifactor authentication by installing the required package with the following command: The openssl-pkcs11 package can be installed with the following command: $ sudo dnf install openssl-pkcs11",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_install_smartcard_packages",
    "rule": "xccdf_org.ssgproject.content_rule_install_smartcard_packages",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ); }; then if ! rpm -q --quiet \"openssl-pkcs11\" ; then dnf install -y \"openssl-pkcs11\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_062",
    "title": "Enable the pcscd Service",
    "description": "The pcscd service can be enabled with the following command: $ sudo systemctl enable pcscd.service",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_pcscd_enabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_pcscd_enabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'pcscd.service' if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" start 'pcscd.service' fi \"$SYSTEMCTL_EXEC\" enable 'pcscd.service' else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_063",
    "title": "Configure opensc Smart Card Drivers",
    "description": "The OpenSC smart card tool can auto-detect smart card drivers; however, setting the smart card drivers in use by your organization helps to prevent users from using unauthorized smart cards. The default smart card driver for this profile is . To configure the OpenSC driver, edit the /etc/opensc.conf and add the following line into the file in the app default block, so it will look like: app default { ... card_drivers = ; }",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_configure_opensc_card_drivers",
    "rule": "xccdf_org.ssgproject.content_rule_configure_opensc_card_drivers",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_smartcard_drivers='' OPENSC_TOOL=\"/usr/bin/opensc-tool\" if [ -f \"${OPENSC_TOOL}\" ]; then ${OPENSC_TOOL} -S app:default:card_drivers:$var_smartcard_drivers fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_064",
    "title": "Only Authorized Local User Accounts Exist on Operating System",
    "description": "Enterprise Application tends to use the server or virtual machine exclusively. Besides the default operating system user, there should be only authorized local users required by the installed software groups and applications that exist on the operating system. The authorized user list can be customized in the refine value variable var_accounts_authorized_local_users_regex. OVAL regular expression is used for the user list. Configure the system so all accounts on the system are assigned to an active system, application, or user account. Remove accounts that do not support approved system activities or that allow for a normal user to perform administrative-level actions. To remove unauthorized system accounts, use the following command: $ sudo userdel unauthorized_user",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_authorized_local_users",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_authorized_local_users",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Only Authorized Local User Accounts Exist on Operating System"
  },
  {
    "id": "openscap_065",
    "title": "Set Account Expiration Following Inactivity",
    "description": "To specify the number of days after a password expires (which signifies inactivity) until an account is permanently disabled, add or correct the following line in /etc/default/useradd: INACTIVE= If a password is currently on the verge of expiration, then day(s) remain(s) until the account is automatically disabled. However, if the password will not expire for another 60 days, then 60 days plus day(s) could elapse until the account would be automatically disabled. See the useradd man page for more information.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration",
    "rule": "xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q shadow-utils; }; then var_account_disable_post_pw_expiration='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^INACTIVE\") # shellcheck disable=SC2059 printf -v formatted_output \"%s=%s\" \"$stripped_key\" \"$var_account_disable_post_pw_expiration\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^INACTIVE\\\\>\" \"/etc/default/useradd\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/"
  },
  {
    "id": "openscap_066",
    "title": "Set Password Maximum Age",
    "description": "To specify password maximum age for new accounts, edit the file /etc/login.defs and add or correct the following line: PASS_MAX_DAYS The profile requirement is .",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q shadow-utils; }; then var_accounts_maximum_age_login_defs='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MAX_DAYS\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_maximum_age_login_defs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^PASS_MAX_DAYS\\\\>\" \"/etc/login.defs\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|"
  },
  {
    "id": "openscap_067",
    "title": "Set Password Minimum Age",
    "description": "To specify password minimum age for new accounts, edit the file /etc/login.defs and add or correct the following line: PASS_MIN_DAYS A value of 1 day is considered sufficient for many environments. The profile requirement is .",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_minimum_age_login_defs",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q shadow-utils; }; then var_accounts_minimum_age_login_defs='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^PASS_MIN_DAYS\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_minimum_age_login_defs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^PASS_MIN_DAYS\\\\>\" \"/etc/login.defs\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|"
  },
  {
    "id": "openscap_068",
    "title": "Set Existing Passwords Maximum Age",
    "description": "Configure non-compliant accounts to enforce a -day maximum password lifetime restriction by running the following command: $ sudo chage -M USER",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_set_max_life_existing",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_set_max_life_existing",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_accounts_maximum_age_login_defs='' while IFS= read -r i; do chage -M $var_accounts_maximum_age_login_defs $i done < <(awk -v var=\"$var_accounts_maximum_age_login_defs\" -F: '(/^[^:]+:[^!*]/ && ($5 > var || $5 == \"\")) {print $1}' /etc/shadow) else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_069",
    "title": "Set Existing Passwords Minimum Age",
    "description": "Configure non-compliant accounts to enforce a 24 hours/1 day minimum password lifetime by running the following command: $ sudo chage -m 1 USER",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_set_min_life_existing",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_set_min_life_existing",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_accounts_minimum_age_login_defs='' while IFS= read -r i; do chage -m $var_accounts_minimum_age_login_defs $i done < <(awk -v var=\"$var_accounts_minimum_age_login_defs\" -F: '(/^[^:]+:[^!*]/ && ($4 < var || $4 == \"\")) {print $1}' /etc/shadow) else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_070",
    "title": "Set number of Password Hashing Rounds - password-auth",
    "description": "Configure the number or rounds for the password hashing algorithm. This can be accomplished by using the rounds option for the pam_unix PAM module. In file /etc/pam.d/password-auth append rounds= to the pam_unix.so entry, as shown below: password sufficient pam_unix.so ...existing_options... rounds= The system's default number of rounds is 5000.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_rounds_password_auth",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_rounds_password_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q pam && rpm --quiet -q kernel-core ); then var_password_pam_unix_rounds='' if [ -e \"/etc/pam.d/password-auth\" ] ; then PAM_FILE_PATH=\"/etc/pam.d/password-auth\" if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }') # If not already in use, a cust"
  },
  {
    "id": "openscap_071",
    "title": "Set number of Password Hashing Rounds - system-auth",
    "description": "Configure the number or rounds for the password hashing algorithm. This can be accomplished by using the rounds option for the pam_unix PAM module. In file /etc/pam.d/system-auth append rounds= to the pam_unix.so entry, as shown below: password sufficient pam_unix.so ...existing_options... rounds= The system's default number of rounds is 5000.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_rounds_system_auth",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_rounds_system_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q pam && rpm --quiet -q kernel-core ); then var_password_pam_unix_rounds='' if [ -e \"/etc/pam.d/system-auth\" ] ; then PAM_FILE_PATH=\"/etc/pam.d/system-auth\" if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }') # If not already in use, a custom p"
  },
  {
    "id": "openscap_072",
    "title": "Prevent Login to Accounts With Empty Password",
    "description": "If an account is configured for password authentication but does not have an assigned password, it may be possible to log into the account without authentication. Remove any instances of the nullok in /etc/pam.d/system-auth and /etc/pam.d/password-auth to prevent logins with empty passwords.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_no_empty_passwords",
    "rule": "xccdf_org.ssgproject.content_rule_no_empty_passwords",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if [ -f /usr/bin/authselect ]; then if ! authselect check; then echo \" authselect integrity check failed. Remediation aborted! This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact. It is not recommended to manually edit the PAM files when authselect tool is available. In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\" exit 1 fi authselect enable-feature without-nullok authselect apply-changes -b else if grep -qP \"^\\s*auth\\s+sufficient\\s+pam_unix.so\\s.*\\bnullok\\b\" \"/etc/pam.d/system-auth\"; then sed -i -E --follow-symlinks \"s/(.*auth.*sufficient.*pam_unix.so.*)\\"
  },
  {
    "id": "openscap_073",
    "title": "Enforce usage of pam_wheel for su authentication",
    "description": "To ensure that only users who are members of the wheel group can run commands with altered privileges through the su command, make sure that the following line exists in the file /etc/pam.d/su: auth required pam_wheel.so use_uid",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_use_pam_wheel_for_su",
    "rule": "xccdf_org.ssgproject.content_rule_use_pam_wheel_for_su",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q pam; then # uncomment the option if commented sed '/^[[:space:]]*#[[:space:]]*auth[[:space:]]\\+required[[:space:]]\\+pam_wheel\\.so[[:space:]]\\+use_uid$/s/^[[:space:]]*#//' -i /etc/pam.d/su else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_074",
    "title": "Ensure the Logon Failure Delay is Set Correctly in login.defs",
    "description": "To ensure the logon failure delay controlled by /etc/login.defs is set properly, add or correct the FAIL_DELAY setting in /etc/login.defs to read as follows: FAIL_DELAY",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_logon_fail_delay",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_logon_fail_delay",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q shadow-utils && rpm --quiet -q kernel-core ); then var_accounts_fail_delay='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^FAIL_DELAY\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_fail_delay\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^FAIL_DELAY\\\\>\" \"/etc/login.defs\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_"
  },
  {
    "id": "openscap_075",
    "title": "Limit the Number of Concurrent Login Sessions Allowed Per User",
    "description": "Limiting the number of allowed users and sessions per user can limit risks related to Denial of Service attacks. This addresses concurrent sessions for a single account and does not address concurrent sessions by a single user via multiple accounts. To set the number of concurrent sessions per user add the following line in /etc/security/limits.conf or a file under /etc/security/limits.d/: * hard maxlogins",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_max_concurrent_login_sessions",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q pam && rpm --quiet -q kernel-core ); then var_accounts_max_concurrent_login_sessions='' if grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.d/*.conf; then sed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.d/*.conf elif grep -q '^[^#]*\\<maxlogins\\>' /etc/security/limits.conf; then sed -i \"/^[^#]*\\<maxlogins\\>/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.conf else echo \"* hard maxlogins $var_accounts_max_concurrent_login_sessions\" >> /etc/security/limits.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_076",
    "title": "Set Interactive Session Timeout",
    "description": "Setting the TMOUT option in /etc/profile ensures that all user sessions will terminate based on inactivity. A value of 0 (zero) disables the automatic logout feature and is therefore not a compliant setting. The value of TMOUT should be a positive integer, exported, and read only. The TMOUT setting in a file loaded by /etc/profile, e.g. /etc/profile.d/tmout.sh should read as follows: typeset -xr TMOUT= or declare -xr TMOUT= Using the typeset keyword is preferred for wider compatibility with ksh and other shells.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_tmout",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_tmout",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_accounts_tmout='' # if 0, no occurrence of tmout found, if 1, occurrence found tmout_found=0 for f in /etc/profile /etc/profile.d/*.sh; do if grep --silent '^[^#].*TMOUT' $f; then sed -i -E \"s/^(.*)TMOUT\\s*=\\s*(\\w|\\$)*(.*)$/typeset -xr TMOUT=$var_accounts_tmout\\3/g\" $f tmout_found=1 fi done if [ $tmout_found -eq 0 ]; then echo -e \"\\n# Set TMOUT to $var_accounts_tmout per security requirements\" >> /etc/profile.d/tmout.sh echo \"typeset -xr TMOUT=$var_accounts_tmout\" >> /etc/profile.d/tmout.sh fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_077",
    "title": "Ensure All User Initialization Files Have Mode 0740 Or Less Permissive",
    "description": "Set the mode of the user initialization files, including the root user, to 0740 with the following commands: $ sudo chmod 0740 /root/.INIT_FILE $ sudo chmod 0740 /home/USER/.INIT_FILE",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permission_user_init_files_root",
    "rule": "xccdf_org.ssgproject.content_rule_file_permission_user_init_files_root",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: var_user_initialization_files_regex='' readarray -t interactive_users < <(awk -F: '$3==0 || $3>=1000 {print $1}' /etc/passwd) readarray -t interactive_users_home < <(awk -F: '$3==0 || $3>=1000 {print $6}' /etc/passwd) readarray -t interactive_users_shell < <(awk -F: '$3==0 || $3>=1000 {print $7}' /etc/passwd) USERS_IGNORED_REGEX='nobody|nfsnobody' for (( i=0; i<\"${#interactive_users[@]}\"; i++ )); do if ! grep -qP \"$USERS_IGNORED_REGEX\" <<< \"${interactive_users[$i]}\" && \\ [ \"${interactive_users_shell[$i]}\" != \"/sbin/nologin\" ]; then readarray -t init_files < <(find \"${interactive_users_home[$i]}\" -maxdepth 1 \\ -exec basename {} \\; | grep -P \"$var_user_initialization_files_regex\") for file in \"${init_files[@]}\"; do chmod u-s,g-wxs,o= \"${interactive_users_home[$i]}/$file\" done fi done"
  },
  {
    "id": "openscap_078",
    "title": "Ensure the Default Bash Umask is Set Correctly",
    "description": "To ensure the default umask for users of the Bash shell is set properly, add or correct the umask setting in /etc/bashrc to read as follows: umask",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_bashrc",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_bashrc",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q bash; }; then var_accounts_user_umask='' grep -q \"^[^#]*\\bumask\" /etc/bashrc && \\ sed -i -E -e \"s/^([^#]*\\bumask)[[:space:]]+[[:digit:]]+/\\1 $var_accounts_user_umask/g\" /etc/bashrc if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" >> /etc/bashrc fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_079",
    "title": "Ensure the Default C Shell Umask is Set Correctly",
    "description": "To ensure the default umask for users of the C shell is set properly, add or correct the umask setting in /etc/csh.cshrc to read as follows: umask",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_csh_cshrc",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_csh_cshrc",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_accounts_user_umask='' grep -q \"^\\s*umask\" /etc/csh.cshrc && \\ sed -i -E -e \"s/^(\\s*umask).*/\\1 $var_accounts_user_umask/g\" /etc/csh.cshrc if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" >> /etc/csh.cshrc fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_080",
    "title": "Ensure the Default Umask is Set Correctly in login.defs",
    "description": "To ensure the default umask controlled by /etc/login.defs is set properly, add or correct the UMASK setting in /etc/login.defs to read as follows: UMASK",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_login_defs",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q shadow-utils; }; then var_accounts_user_umask='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^UMASK\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_user_umask\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^UMASK\\\\>\" \"/etc/login.defs\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed"
  },
  {
    "id": "openscap_081",
    "title": "Ensure the Default Umask is Set Correctly in /etc/profile",
    "description": "To ensure the default umask controlled by /etc/profile is set properly, add or correct the umask setting in /etc/profile to read as follows: umask Note that /etc/profile also reads scripts within /etc/profile.d directory. These scripts are also valid files to set umask value. Therefore, they should also be considered during the check and properly remediated, if necessary.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_profile",
    "rule": "xccdf_org.ssgproject.content_rule_accounts_umask_etc_profile",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_accounts_user_umask='' readarray -t profile_files < <(find /etc/profile.d/ -type f -name '*.sh' -or -name 'sh.local') for file in \"${profile_files[@]}\" /etc/profile; do grep -qE '^[^#]*umask' \"$file\" && sed -i -E \"s/^(\\s*umask\\s*)[0-7]+/\\1$var_accounts_user_umask/g\" \"$file\" done if ! grep -qrE '^[^#]*umask' /etc/profile*; then echo \"umask $var_accounts_user_umask\" >> /etc/profile fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_082",
    "title": "The system must booted with init_on_free=1",
    "description": "Setting init_on_free=1 on boot guarantees that pages and heap objects are initialized right after they're freed, so it won't be possible to access stale data by using a dangling pointer.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_init_on_free",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_init_on_free",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q grub2-common && rpm --quiet -q kernel-core ) && { rpm --quiet -q grub2-common; }; then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then KARGS_DIR=\"/usr/lib/bootc/kargs.d/\" if grep -q -E \"init_on_free\" \"$KARGS_DIR/*.toml\" ; then sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"init_on_free=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"init_on_free=1\\\"\\2/\" \"$KARGS_DIR/*.toml\" else echo \"kargs = [\\\"init_on_free=1\\\"]\" >> \"$KARGS_DIR/10-init_on_free.toml\" fi else grubby --update-kernel=ALL --args=init_on_free=1 fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_083",
    "title": "Enable Kernel Page-Table Isolation (KPTI)",
    "description": "To enable Kernel page-table isolation, add the argument pti=on to the default GRUB 2 command line for the Linux operating system. To ensure that pti=on is added as a kernel command line argument to newly installed kernels, add pti=on to the default Grub2 command line for Linux operating systems. Modify the line within /etc/default/grub as shown below: GRUB_CMDLINE_LINUX=\"... pti=on ...\" Run the following command to update command line for already installed kernels:# grubby --update-kernel=ALL --args=\"pti=on\" If the system is distributed as a bootable container image, GRUB2 can't be configured using the method described above, but the following method needs to be used instead. The kernel arguments should be set in /usr/lib/bootc/kargs.d in a TOML file that has the following form: # /usr/lib/bootc/kargs.d/10-example.toml kargs = [\"pti=on\"] For more details on configuring kernel arguments in bootable container images, please refer to Bootc documentation.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_pti_argument",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_pti_argument",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( rpm --quiet -q grub2-common && rpm --quiet -q kernel-core ); then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then KARGS_DIR=\"/usr/lib/bootc/kargs.d/\" if grep -q -E \"pti\" \"$KARGS_DIR/*.toml\" ; then sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"pti=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"pti=on\\\"\\2/\" \"$KARGS_DIR/*.toml\" else echo \"kargs = [\\\"pti=on\\\"]\" >> \"$KARGS_DIR/10-pti.toml\" fi else grubby --update-kernel=ALL --args=pti=on fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_084",
    "title": "Set the Boot Loader Admin Username to a Non-Default Value",
    "description": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings. To maximize the protection, select a password-protected superuser account with unique name, and modify the /etc/grub.d/01_users configuration file to reflect the account name change. Do not to use common administrator account names like root, admin, or administrator for the grub2 superuser account. Change the superuser to a different username (The default is 'root'). $ sed -i 's/\\(set superusers=\\).*/\\1\"<unique user ID>\"/g' /etc/grub.d/01_users The line mentioned above must be followed by the line export superusers so that the superusers is honored. Once the superuser account has been added, update the grub.cfg file by running: grub2-mkconfig -o /boot/grub2/grub.cfg",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_admin_username",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_admin_username",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Set the Boot Loader Admin Username to a Non-Default Value"
  },
  {
    "id": "openscap_085",
    "title": "Set Boot Loader Password in grub2",
    "description": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings. Since plaintext passwords are a security risk, generate a hash for the password by running the following command: # grub2-setpassword When prompted, enter the password that was selected.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_password",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_password",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Set Boot Loader Password in grub2"
  },
  {
    "id": "openscap_086",
    "title": "Ensure Rsyslog Authenticates Off-Loaded Audit Records",
    "description": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with gnutls (which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When using rsyslogd to off-load logs the remote system must be authenticated. Set the following configuration option in /etc/rsyslog.conf or in a file in /etc/rsyslog.d (using legacy syntax): $ActionSendStreamDriverAuthMode x509/name Alternatively, use the RainerScript syntax: action(type=\"omfwd\" Target=\"some.example.com\" StreamDriverAuthMode=\"x509/name\")",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_actionsendstreamdriverauthmode",
    "rule": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_actionsendstreamdriverauthmode",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && rpm --quiet -q rsyslog; then RSYSLOG_CONF='/etc/rsyslog.conf' RSYSLOG_D_FOLDER='/etc/rsyslog.d' RSYSLOG_D_CONF='/etc/rsyslog.d/encrypt.conf' test -f $RSYSLOG_CONF || touch $RSYSLOG_CONF mkdir -p $RSYSLOG_D_FOLDER # remove legacy entries sed -i '/^[[:space:]]*\\$ActionSendStreamDriverAuthMode/d' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*\\$ActionSendStreamDriverAuthMode/d' {} + # remove all multilined and onelined RainerScript entries sed -i '/^[[:space:]]*action(/ { :a; N; /)/!ba; /StreamDriverAuthMode/d }' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*action(/ { :a; N; /)/!ba; /StreamDriverAuthMode/d }' {} + if [ -e \"$"
  },
  {
    "id": "openscap_087",
    "title": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
    "description": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with gnutls (which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When using rsyslogd to off-load logs off a encryption system must be used. Set the following configuration option in /etc/rsyslog.conf or in a file in /etc/rsyslog.d (using legacy syntax): $ActionSendStreamDriverMode 1 Alternatively, use the RainerScript syntax: action(type=\"omfwd\" ... StreamDriverMode=\"1\")",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_actionsendstreamdrivermode",
    "rule": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_actionsendstreamdrivermode",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && rpm --quiet -q rsyslog; then RSYSLOG_CONF='/etc/rsyslog.conf' RSYSLOG_D_FOLDER='/etc/rsyslog.d' RSYSLOG_D_CONF='/etc/rsyslog.d/encrypt.conf' test -f $RSYSLOG_CONF || touch $RSYSLOG_CONF mkdir -p $RSYSLOG_D_FOLDER # remove ActionSendStreamDriverMode entries sed -i '/^[[:space:]]*\\$ActionSendStreamDriverMode/d' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*\\$ActionSendStreamDriverMode/d' {} + # remove all multilined and onelined RainerScript entries sed -i '/^[[:space:]]*action(/ { :a; N; /)/!ba; /StreamDriverMode/d }' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*action(/ { :a; N; /)/!ba; /StreamDriverMode/d }' {} + if [ -"
  },
  {
    "id": "openscap_088",
    "title": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
    "description": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with gnutls (which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When using rsyslogd to off-load logs off an encryption system must be used. Set the following configuration option in /etc/rsyslog.conf or in a file in /etc/rsyslog.d (using legacy syntax): $DefaultNetstreamDriver gtls Alternatively, use the RainerScript syntax: global(DefaultNetstreamDriver=\"gtls\")",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_defaultnetstreamdriver",
    "rule": "xccdf_org.ssgproject.content_rule_rsyslog_encrypt_offload_defaultnetstreamdriver",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && rpm --quiet -q rsyslog; then RSYSLOG_CONF='/etc/rsyslog.conf' RSYSLOG_D_FOLDER='/etc/rsyslog.d' RSYSLOG_D_CONF='/etc/rsyslog.d/encrypt.conf' test -f $RSYSLOG_CONF || touch $RSYSLOG_CONF mkdir -p $RSYSLOG_D_FOLDER # remove DefaultNetstreamDriver entries sed -i '/^[[:space:]]*\\$DefaultNetstreamDriver/d' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*\\$DefaultNetstreamDriver/d' {} + # remove all multilined and onelined RainerScript entries sed -i '/^[[:space:]]*global(/ { :a; N; /)/!ba; /DefaultNetstreamDriver/d }' $RSYSLOG_CONF find $RSYSLOG_D_FOLDER -type f -name \"*.conf\" -exec sed -i '/^[[:space:]]*global(/ { :a; N; /)/!ba; /DefaultNetstreamDriver/d }' {} + if [ -"
  },
  {
    "id": "openscap_089",
    "title": "Ensure remote access methods are monitored in Rsyslog",
    "description": "Logging of remote access methods must be implemented to help identify cyber attacks and ensure ongoing compliance with remote access policies are being audited and upheld. An examples of a remote access method is the use of the Remote Desktop Protocol (RDP) from an external, non-organization controlled network. The /etc/rsyslog.conf or /etc/rsyslog.d/*.conf file should contain a match for the following selectors: auth.*, authpriv.*, and daemon.*. If not, use the following as an example configuration: auth.*;authpriv.* /var/log/secure daemon.* /var/log/messages",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring",
    "rule": "xccdf_org.ssgproject.content_rule_rsyslog_remote_access_monitoring",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && rpm --quiet -q rsyslog; then declare -A REMOTE_METHODS=( ['auth.*']='^[^#]*auth\\.\\*.*$' ['authpriv.*']='^[^#]*authpriv\\.\\*.*$' ['daemon.*']='^[^#]*daemon\\.\\*.*$' ) declare -A LOCATIONS=( ['auth.*']='/var/log/secure' ['authpriv.*']='/var/log/secure' ['daemon.*']='/var/log/messages' ) if [[ ! -f /etc/rsyslog.conf ]]; then # Something is not right, create the file touch /etc/rsyslog.conf fi # Loop through the remote methods associative array for K in \"${!REMOTE_METHODS[@]}\" do # Check to see if selector/value exists if ! grep -rq \"${REMOTE_METHODS[$K]}\" /etc/rsyslog.*; then APPEND_LINE=$(sed -rn \"/^\\S+\\s+\\${LOCATIONS[$K]}$/p\" /etc/rsyslog.conf) # Make sure we have a line to insert after, otherwise append to"
  },
  {
    "id": "openscap_090",
    "title": "Ensure Logs Sent To Remote Host",
    "description": "To configure rsyslog to send logs to a remote log server, open /etc/rsyslog.conf and read and understand the last section of the file, which describes the multiple directives necessary to activate remote logging. Along with these other directives, the system can be configured to forward its logs to a particular log server by adding or correcting one of the following lines, substituting appropriately. The choice of protocol depends on the environment of the system; although TCP and RELP provide more reliable message delivery, they may not be supported in all environments. To use UDP for log message delivery: *.* @ Or in RainerScript: *.* action(type=\"omfwd\" ... target=\"\" protocol=\"udp\") To use TCP for log message delivery: *.* @@ Or in RainerScript: *.* action(type=\"omfwd\" ... target=\"\" protocol=\"tcp\") To use RELP for log message delivery: *.* :omrelp: Or in RainerScript: *.* action(type=\"omfwd\" ... target=\"\" protocol=\"relp\") There must be a resolvable DNS CNAME or Alias record set to \"\" for logs to be sent correctly to the centralized logging utility.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rsyslog_remote_loghost",
    "rule": "xccdf_org.ssgproject.content_rule_rsyslog_remote_loghost",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then rsyslog_remote_loghost_address='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^\\*\\.\\*\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"@@$rsyslog_remote_loghost_address\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^\\*\\.\\*\\\\>\" \"/etc/rsyslog.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --follow-sym"
  },
  {
    "id": "openscap_091",
    "title": "Configure Multiple DNS Servers in /etc/resolv.conf",
    "description": "Determine whether the system is using local or DNS name resolution with the following command: $ sudo grep hosts /etc/nsswitch.conf hosts: files dns If the DNS entry is missing from the host's line in the \"/etc/nsswitch.conf\" file, the \"/etc/resolv.conf\" file must be empty. Verify the \"/etc/resolv.conf\" file is empty with the following command: $ sudo ls -al /etc/resolv.conf -rw-r--r-- 1 root root 0 Aug 19 08:31 resolv.conf If the DNS entry is found on the host's line of the \"/etc/nsswitch.conf\" file, then verify the following: Multiple Domain Name System (DNS) Servers should be configured in /etc/resolv.conf. This provides redundant name resolution services in the event that a domain server crashes. To configure the system to contain as least 2 DNS servers, add a corresponding nameserver ip_address entry in /etc/resolv.conf for each DNS server where ip_address is the IP address of a valid DNS server. For example: search example.com nameserver 192.168.0.1 nameserver 192.168.0.2",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_network_configure_name_resolution",
    "rule": "xccdf_org.ssgproject.content_rule_network_configure_name_resolution",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Configure Multiple DNS Servers in /etc/resolv.conf"
  },
  {
    "id": "openscap_092",
    "title": "Install libreswan Package",
    "description": "The libreswan package provides an implementation of IPsec and IKE, which permits the creation of secure tunnels over untrusted networks. The libreswan package can be installed with the following command: $ sudo dnf install libreswan",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_libreswan_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_libreswan_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"libreswan\" ; then dnf install -y \"libreswan\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_093",
    "title": "Configure Accepting Router Advertisements on All IPv6 Interfaces",
    "description": "To set the runtime status of the net.ipv6.conf.all.accept_ra kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.all.accept_ra=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.all.accept_ra = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_ra",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_ra",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.all.accept_ra from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.all.accept_ra.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.all.accept_ra\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl co"
  },
  {
    "id": "openscap_094",
    "title": "Disable Accepting ICMP Redirects for All IPv6 Interfaces",
    "description": "To set the runtime status of the net.ipv6.conf.all.accept_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.all.accept_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.all.accept_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.all.accept_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.all.accept_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.all.accept_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi d"
  },
  {
    "id": "openscap_095",
    "title": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv6 Interfaces",
    "description": "To set the runtime status of the net.ipv6.conf.all.accept_source_route kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.all.accept_source_route=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.all.accept_source_route = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_source_route",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_accept_source_route",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.all.accept_source_route from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.all.accept_source_route.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.all.accept_source_route\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_l"
  },
  {
    "id": "openscap_096",
    "title": "Disable Kernel Parameter for IPv6 Forwarding",
    "description": "To set the runtime status of the net.ipv6.conf.all.forwarding kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.all.forwarding=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.all.forwarding = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_forwarding",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_all_forwarding",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.all.forwarding from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.all.forwarding.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.all.forwarding\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl"
  },
  {
    "id": "openscap_097",
    "title": "Disable Accepting Router Advertisements on all IPv6 Interfaces by Default",
    "description": "To set the runtime status of the net.ipv6.conf.default.accept_ra kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.default.accept_ra=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.default.accept_ra = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_ra",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_ra",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.default.accept_ra from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.default.accept_ra.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.default.accept_ra\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # S"
  },
  {
    "id": "openscap_098",
    "title": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces",
    "description": "To set the runtime status of the net.ipv6.conf.default.accept_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.default.accept_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.default.accept_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.default.accept_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.default.accept_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.default.accept_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matchin"
  },
  {
    "id": "openscap_099",
    "title": "Disable Kernel Parameter for Accepting Source-Routed Packets on IPv6 Interfaces by Default",
    "description": "To set the runtime status of the net.ipv6.conf.default.accept_source_route kernel parameter, run the following command: $ sudo sysctl -w net.ipv6.conf.default.accept_source_route=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv6.conf.default.accept_source_route = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_source_route",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv6_conf_default_accept_source_route",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv6.conf.default.accept_source_route from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv6.conf.default.accept_source_route.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv6.conf.default.accept_source_route\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< "
  },
  {
    "id": "openscap_100",
    "title": "Disable Accepting ICMP Redirects for All IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.accept_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.accept_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.accept_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.accept_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.accept_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.accept_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi d"
  },
  {
    "id": "openscap_101",
    "title": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.accept_source_route kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.accept_source_route=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.accept_source_route = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_source_route",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_accept_source_route",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.accept_source_route from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.accept_source_route.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.accept_source_route\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_l"
  },
  {
    "id": "openscap_102",
    "title": "Disable Kernel Parameter for IPv4 Forwarding on all IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.forwarding kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.forwarding=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.forwarding = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_forwarding",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_forwarding",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.forwarding from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.forwarding.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.forwarding\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl"
  },
  {
    "id": "openscap_103",
    "title": "Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.log_martians kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.log_martians=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.log_martians = 1",
    "severity": "0",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_log_martians",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_log_martians",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.log_martians from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.log_martians.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.log_martians\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set "
  },
  {
    "id": "openscap_104",
    "title": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.rp_filter kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.rp_filter=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.rp_filter = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_rp_filter",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_rp_filter",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.rp_filter from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.rp_filter.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.rp_filter\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl co"
  },
  {
    "id": "openscap_105",
    "title": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.default.accept_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.default.accept_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.default.accept_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_accept_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_accept_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.default.accept_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.default.accept_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.default.accept_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matchin"
  },
  {
    "id": "openscap_106",
    "title": "Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces by Default",
    "description": "To set the runtime status of the net.ipv4.conf.default.log_martians kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.default.log_martians=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.default.log_martians = 1",
    "severity": "0",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_log_martians",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_log_martians",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.default.log_martians from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.default.log_martians.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.default.log_martians\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi d"
  },
  {
    "id": "openscap_107",
    "title": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces by Default",
    "description": "To set the runtime status of the net.ipv4.conf.default.rp_filter kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.default.rp_filter=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.default.rp_filter = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_rp_filter",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_rp_filter",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.default.rp_filter from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.default.rp_filter.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.default.rp_filter\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # S"
  },
  {
    "id": "openscap_108",
    "title": "Enable Kernel Parameter to Ignore ICMP Broadcast Echo Requests on IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.icmp_echo_ignore_broadcasts kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.icmp_echo_ignore_broadcasts=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.icmp_echo_ignore_broadcasts = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_echo_ignore_broadcasts",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_echo_ignore_broadcasts",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.icmp_echo_ignore_broadcasts from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.icmp_echo_ignore_broadcasts.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.icmp_echo_ignore_broadcasts\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list"
  },
  {
    "id": "openscap_109",
    "title": "Enable Kernel Parameter to Ignore Bogus ICMP Error Responses on IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.icmp_ignore_bogus_error_responses kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.icmp_ignore_bogus_error_responses=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.icmp_ignore_bogus_error_responses = 1",
    "severity": "0",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_ignore_bogus_error_responses",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_icmp_ignore_bogus_error_responses",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.icmp_ignore_bogus_error_responses from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.icmp_ignore_bogus_error_responses.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.icmp_ignore_bogus_error_responses\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <"
  },
  {
    "id": "openscap_110",
    "title": "Enable Kernel Parameter to Use TCP Syncookies on Network Interfaces",
    "description": "To set the runtime status of the net.ipv4.tcp_syncookies kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.tcp_syncookies=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.tcp_syncookies = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_tcp_syncookies",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.tcp_syncookies from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.tcp_syncookies.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.tcp_syncookies\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config file wh"
  },
  {
    "id": "openscap_111",
    "title": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces",
    "description": "To set the runtime status of the net.ipv4.conf.all.send_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.all.send_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.all.send_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_send_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_all_send_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.all.send_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.all.send_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.all.send_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # "
  },
  {
    "id": "openscap_112",
    "title": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces by Default",
    "description": "To set the runtime status of the net.ipv4.conf.default.send_redirects kernel parameter, run the following command: $ sudo sysctl -w net.ipv4.conf.default.send_redirects=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.ipv4.conf.default.send_redirects = 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_send_redirects",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_ipv4_conf_default_send_redirects",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.ipv4.conf.default.send_redirects from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.ipv4.conf.default.send_redirects.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.ipv4.conf.default.send_redirects\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list"
  },
  {
    "id": "openscap_113",
    "title": "Disable ATM Support",
    "description": "The Asynchronous Transfer Mode (ATM) is a protocol operating on network, data link, and physical layers, based on virtual circuits and virtual paths. To configure the system to prevent the atm kernel module from being loaded, add the following line to the file /etc/modprobe.d/atm.conf: install atm /bin/false This entry will cause a non-zero return value during a atm module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install atm /bin/true",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_atm_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_atm_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install atm\" /etc/modprobe.d/atm.conf ; then sed -i 's#^install atm.*#install atm /bin/false#g' /etc/modprobe.d/atm.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/atm.conf echo \"install atm /bin/false\" >> /etc/modprobe.d/atm.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist atm$\" /etc/modprobe.d/atm.conf ; then echo \"blacklist atm\" >> /etc/modprobe.d/atm.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_114",
    "title": "Disable CAN Support",
    "description": "The Controller Area Network (CAN) is a serial communications protocol which was initially developed for automotive and is now also used in marine, industrial, and medical applications. To configure the system to prevent the can kernel module from being loaded, add the following line to the file /etc/modprobe.d/can.conf: install can /bin/false This entry will cause a non-zero return value during a can module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install can /bin/true",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_can_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_can_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install can\" /etc/modprobe.d/can.conf ; then sed -i 's#^install can.*#install can /bin/false#g' /etc/modprobe.d/can.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/can.conf echo \"install can /bin/false\" >> /etc/modprobe.d/can.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist can$\" /etc/modprobe.d/can.conf ; then echo \"blacklist can\" >> /etc/modprobe.d/can.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_115",
    "title": "Disable IEEE 1394 (FireWire) Support",
    "description": "The IEEE 1394 (FireWire) is a serial bus standard for high-speed real-time communication. To configure the system to prevent the firewire-core kernel module from being loaded, add the following line to the file /etc/modprobe.d/firewire-core.conf: install firewire-core /bin/false This entry will cause a non-zero return value during a firewire-core module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install firewire-core /bin/true",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_firewire-core_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_firewire-core_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install firewire-core\" /etc/modprobe.d/firewire-core.conf ; then sed -i 's#^install firewire-core.*#install firewire-core /bin/false#g' /etc/modprobe.d/firewire-core.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/firewire-core.conf echo \"install firewire-core /bin/false\" >> /etc/modprobe.d/firewire-core.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist firewire-core$\" /etc/modprobe.d/firewire-core.conf ; then echo \"blacklist firewire-core\" >> /etc/modprobe.d/firewire-core.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_116",
    "title": "Disable SCTP Support",
    "description": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol, designed to support the idea of message-oriented communication, with several streams of messages within one connection. To configure the system to prevent the sctp kernel module from being loaded, add the following line to the file /etc/modprobe.d/sctp.conf: install sctp /bin/false This entry will cause a non-zero return value during a sctp module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install sctp /bin/true",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_sctp_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_sctp_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install sctp\" /etc/modprobe.d/sctp.conf ; then sed -i 's#^install sctp.*#install sctp /bin/false#g' /etc/modprobe.d/sctp.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/sctp.conf echo \"install sctp /bin/false\" >> /etc/modprobe.d/sctp.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist sctp$\" /etc/modprobe.d/sctp.conf ; then echo \"blacklist sctp\" >> /etc/modprobe.d/sctp.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_117",
    "title": "Disable TIPC Support",
    "description": "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communications between nodes in a cluster. To configure the system to prevent the tipc kernel module from being loaded, add the following line to the file /etc/modprobe.d/tipc.conf: install tipc /bin/false This entry will cause a non-zero return value during a tipc module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install tipc /bin/true",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_tipc_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_tipc_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install tipc\" /etc/modprobe.d/tipc.conf ; then sed -i 's#^install tipc.*#install tipc /bin/false#g' /etc/modprobe.d/tipc.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/tipc.conf echo \"install tipc /bin/false\" >> /etc/modprobe.d/tipc.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist tipc$\" /etc/modprobe.d/tipc.conf ; then echo \"blacklist tipc\" >> /etc/modprobe.d/tipc.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_118",
    "title": "Disable Bluetooth Kernel Module",
    "description": "The kernel's module loading system can be configured to prevent loading of the Bluetooth module. Add the following to the appropriate /etc/modprobe.d configuration file to prevent the loading of the Bluetooth module: install bluetooth /bin/true",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_bluetooth_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_bluetooth_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install bluetooth\" /etc/modprobe.d/bluetooth.conf ; then sed -i 's#^install bluetooth.*#install bluetooth /bin/false#g' /etc/modprobe.d/bluetooth.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/bluetooth.conf echo \"install bluetooth /bin/false\" >> /etc/modprobe.d/bluetooth.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist bluetooth$\" /etc/modprobe.d/bluetooth.conf ; then echo \"blacklist bluetooth\" >> /etc/modprobe.d/bluetooth.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_119",
    "title": "NetworkManager DNS Mode Must Be Must Configured",
    "description": "The DNS processing mode in NetworkManager describes how DNS is processed on the system. Depending the mode some changes the system's DNS may not be respected.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_networkmanager_dns_mode",
    "rule": "xccdf_org.ssgproject.content_rule_networkmanager_dns_mode",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q NetworkManager; then var_networkmanager_dns_mode='' found=false # set value in all files if they contain section or key for f in $(echo -n \"/etc/NetworkManager/conf.d/complianceascode_hardening.conf /etc/NetworkManager/conf.d/*.conf /etc/NetworkManager/NetworkManager.conf\"); do if [ ! -e \"$f\" ]; then continue fi # find key in section and change value if grep -qzosP \"[[:space:]]*\\[main\\]([^\\n\\[]*\\n+)+?[[:space:]]*dns\" \"$f\"; then if ! grep -qPz \"dns=$var_networkmanager_dns_mode\" \"$f\"; then sed -i \"s/dns[^(\\n)]*/dns=$var_networkmanager_dns_mode/\" \"$f\" fi found=true # find section and add key = value to it elif grep -qs \"[[:space:]]*\\[main\\]\" \"$f\"; then sed -i \"/[[:space:]]*\\[main\\]/a dns=$var_networkmanager_dns_mode\" \"$f\""
  },
  {
    "id": "openscap_120",
    "title": "Ensure rootfiles tmpfile.d is Configured Correctly",
    "description": "To set the mode of the root user initialization file /root/.bash_profile, ensure the following lines are is included in a file ending in .conf under /etc/tmpfiles.d/. C /root/.bash_logout 600 root root - /usr/share/rootfiles/.bash_logout C /root/.bash_profile 600 root root - /usr/share/rootfiles/.bash_profile C /root/.bashrc 600 root root - /usr/share/rootfiles/.bashrc C /root/.cshrc 600 root root - /usr/share/rootfiles/.cshrc C /root/.tcshrc 600 root root - /usr/share/rootfiles/.tcshrc",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_rootfiles_configured",
    "rule": "xccdf_org.ssgproject.content_rule_rootfiles_configured",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q rootfiles; then find \"/etc/tmpfiles.d/\" -name \"*.conf\" -print0 | xargs -0 sed -i \"/C[[:space:]]*\\/root\\/.bash_logout/d\" find \"/etc/tmpfiles.d/\" -name \"*.conf\" -print0 | xargs -0 sed -i \"/C[[:space:]]*\\/root\\/.bash_profile/d\" find \"/etc/tmpfiles.d/\" -name \"*.conf\" -print0 | xargs -0 sed -i \"/C[[:space:]]*\\/root\\/.bashrc/d\" find \"/etc/tmpfiles.d/\" -name \"*.conf\" -print0 | xargs -0 sed -i \"/C[[:space:]]*\\/root\\/.cshrc/d\" find \"/etc/tmpfiles.d/\" -name \"*.conf\" -print0 | xargs -0 sed -i \"/C[[:space:]]*\\/root\\/.tcshrc/d\" cat << 'EOF' > /etc/tmpfiles.d/rootfiles.conf C /root/.bash_logout 600 root root - /usr/share/rootfiles/.bash_logout C /root/.bash_profile 600 root root - /usr/share/rootfiles/.bash_profile C /root/.bashrc 6"
  },
  {
    "id": "openscap_121",
    "title": "Disable Mounting of cramfs",
    "description": "To configure the system to prevent the cramfs kernel module from being loaded, add the following line to the file /etc/modprobe.d/cramfs.conf: install cramfs /bin/false This entry will cause a non-zero return value during a cramfs module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install cramfs /bin/true This effectively prevents usage of this uncommon filesystem. The cramfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A cramfs image can be used without having to first decompress the image.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_cramfs_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_cramfs_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install cramfs\" /etc/modprobe.d/cramfs.conf ; then sed -i 's#^install cramfs.*#install cramfs /bin/false#g' /etc/modprobe.d/cramfs.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/cramfs.conf echo \"install cramfs /bin/false\" >> /etc/modprobe.d/cramfs.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist cramfs$\" /etc/modprobe.d/cramfs.conf ; then echo \"blacklist cramfs\" >> /etc/modprobe.d/cramfs.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_122",
    "title": "Disable Modprobe Loading of USB Storage Driver",
    "description": "To prevent USB storage devices from being used, configure the kernel module loading system to prevent automatic loading of the USB storage driver. To configure the system to prevent the usb-storage kernel module from being loaded, add the following line to the file /etc/modprobe.d/usb-storage.conf: install usb-storage /bin/false This entry will cause a non-zero return value during a usb-storage module installation and additionally convey the meaning of the entry to the user in form of an error message. If you would like to omit a non-zero return value and an error message, you may want to add a different line instead (both /bin/true and /bin/false are allowed by OVAL and will be accepted by the scan): install usb-storage /bin/true This will prevent the modprobe program from loading the usb-storage module, but will not prevent an administrator (or another program) from using the insmod program to load the module manually.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_kernel_module_usb-storage_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if LC_ALL=C grep -q -m 1 \"^install usb-storage\" /etc/modprobe.d/usb-storage.conf ; then sed -i 's#^install usb-storage.*#install usb-storage /bin/false#g' /etc/modprobe.d/usb-storage.conf else echo -e \"\\n# Disable per security requirements\" >> /etc/modprobe.d/usb-storage.conf echo \"install usb-storage /bin/false\" >> /etc/modprobe.d/usb-storage.conf fi if ! LC_ALL=C grep -q -m 1 \"^blacklist usb-storage$\" /etc/modprobe.d/usb-storage.conf ; then echo \"blacklist usb-storage\" >> /etc/modprobe.d/usb-storage.conf fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_123",
    "title": "Add nosuid Option to /boot/efi",
    "description": "The nosuid mount option can be used to prevent execution of setuid programs in /boot/efi. The SUID and SGID permissions should not be required on the boot partition. Add the nosuid option to the fourth column of /etc/fstab for the line which controls mounting of /boot/efi.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_boot_efi_nosuid",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_boot_efi_nosuid",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ) && { findmnt --kernel \"/boot/efi\" > /dev/null || findmnt --fstab \"/boot/efi\" > /dev/null; }; then function perform_remediation { # the mount point /boot/efi has to be defined in /etc/fstab # before this remediation can be executed. In case it is not defined, the # remediation aborts and no changes regarding the mount point are done. mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" \"/boot/efi\")\" grep \"$mount_point_match_regexp\" -q /etc/fstab \\ || { echo "
  },
  {
    "id": "openscap_124",
    "title": "Add nodev Option to /boot",
    "description": "The nodev mount option can be used to prevent device files from being created in /boot. Legitimate character and block devices should exist only in the /dev directory on the root partition or within chroot jails built for system services. Add the nodev option to the fourth column of /etc/fstab for the line which controls mounting of /boot.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_boot_nodev",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_boot_nodev",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then function perform_remediation { # the mount point /boot has to be defined in /etc/fstab # before this remediation can be executed. In case it is not defined, the # remediation aborts and no changes regarding the mount point are done. mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" \"/boot\")\" grep \"$mount_point_match_regexp\" -q /etc/fstab \\ || { echo \"The mount point '/boot' is not even in /etc/fstab, so we can't set up mount options\" >&2; echo \"Not"
  },
  {
    "id": "openscap_125",
    "title": "Add nosuid Option to /boot",
    "description": "The nosuid mount option can be used to prevent execution of setuid programs in /boot. The SUID and SGID permissions should not be required on the boot partition. Add the nosuid option to the fourth column of /etc/fstab for the line which controls mounting of /boot.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_boot_nosuid",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_boot_nosuid",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then function perform_remediation { # the mount point /boot has to be defined in /etc/fstab # before this remediation can be executed. In case it is not defined, the # remediation aborts and no changes regarding the mount point are done. mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" \"/boot\")\" grep \"$mount_point_match_regexp\" -q /etc/fstab \\ || { echo \"The mount point '/boot' is not even in /etc/fstab, so we can't set up mount options\" >&2; echo \"Not"
  },
  {
    "id": "openscap_126",
    "title": "Add nodev Option to /dev/shm",
    "description": "The nodev mount option can be used to prevent creation of device files in /dev/shm. Legitimate character and block devices should not exist within temporary directories like /dev/shm. Add the nodev option to the fourth column of /etc/fstab for the line which controls mounting of /dev/shm.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nodev",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nodev",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then function perform_remediation { mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if ! grep -q \"$mount_point_match_regexp\" /etc/fstab; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|nodev)(,|$)//g;s/"
  },
  {
    "id": "openscap_127",
    "title": "Add noexec Option to /dev/shm",
    "description": "The noexec mount option can be used to prevent binaries from being executed out of /dev/shm. It can be dangerous to allow the execution of binaries from world-writable temporary storage directories such as /dev/shm. Add the noexec option to the fourth column of /etc/fstab for the line which controls mounting of /dev/shm.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_noexec",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_noexec",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then function perform_remediation { mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if ! grep -q \"$mount_point_match_regexp\" /etc/fstab; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|noexec)(,|$)//g;s"
  },
  {
    "id": "openscap_128",
    "title": "Add nosuid Option to /dev/shm",
    "description": "The nosuid mount option can be used to prevent execution of setuid programs in /dev/shm. The SUID and SGID permissions should not be required in these world-writable directories. Add the nosuid option to the fourth column of /etc/fstab for the line which controls mounting of /dev/shm.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nosuid",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_dev_shm_nosuid",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then function perform_remediation { mount_point_match_regexp=\"$(printf \"^[[:space:]]*[^#].*[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if ! grep -q \"$mount_point_match_regexp\" /etc/fstab; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|nosuid)(,|$)//g;s"
  },
  {
    "id": "openscap_129",
    "title": "Add nodev Option to Non-Root Local Partitions",
    "description": "The nodev mount option prevents files from being interpreted as character or block devices. Legitimate character and block devices should exist only in the /dev directory on the root partition or within chroot jails built for system services. Add the nodev option to the fourth column of /etc/fstab for the line which controls mounting of any non-root local partitions.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_mount_option_nodev_nonroot_local_partitions",
    "rule": "xccdf_org.ssgproject.content_rule_mount_option_nodev_nonroot_local_partitions",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( { rpm --quiet -q kernel-core ;} && { rpm --quiet -q rpm-ostree ;} && { rpm --quiet -q bootc ;} && { ! rpm --quiet -q openshift-kubelet ;} && ([ -f /run/ostree-booted ] || [ -L /ostree ]) ) && ! ( [ -f /.dockerenv ] || [ -f /run/.containerenv ] ) ); then MOUNT_OPTION=\"nodev\" # Create array of local non-root partitions readarray -t partitions_records < <(findmnt --mtab --raw --evaluate | grep \"^/\\w\" | grep -v \"^/proc\" | grep \"\\s/dev/\\w\") # Create array of polyinstantiated directories, in case one of them is found in mtab readarray -t polyinstantiated_dirs < \\ <(grep -oP \"^\\s*[^#\\s]+\\s+\\S+\" /etc/security/namespace.conf | grep -oP \"(?<=\\s)\\S+?(?=/?\\$)\") # Define excluded non-local file systems excluded_fstypes=( afs autofs ceph cif"
  },
  {
    "id": "openscap_130",
    "title": "Disable storing core dumps",
    "description": "To set the runtime status of the kernel.core_pattern kernel parameter, run the following command: $ sudo sysctl -w kernel.core_pattern=|/bin/false To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.core_pattern = |/bin/false",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_core_pattern",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_core_pattern",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.core_pattern from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.core_pattern.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.core_pattern\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config file which to save "
  },
  {
    "id": "openscap_131",
    "title": "Restrict Access to Kernel Message Buffer",
    "description": "To set the runtime status of the kernel.dmesg_restrict kernel parameter, run the following command: $ sudo sysctl -w kernel.dmesg_restrict=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.dmesg_restrict = 1",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_dmesg_restrict",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.dmesg_restrict from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.dmesg_restrict.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.dmesg_restrict\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config file which to"
  },
  {
    "id": "openscap_132",
    "title": "Disable Kernel Image Loading",
    "description": "To set the runtime status of the kernel.kexec_load_disabled kernel parameter, run the following command: $ sudo sysctl -w kernel.kexec_load_disabled=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.kexec_load_disabled = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_kexec_load_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_kexec_load_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.kexec_load_disabled from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.kexec_load_disabled.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.kexec_load_disabled\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl confi"
  },
  {
    "id": "openscap_133",
    "title": "Disallow kernel profiling by unprivileged users",
    "description": "To set the runtime status of the kernel.perf_event_paranoid kernel parameter, run the following command: $ sudo sysctl -w kernel.perf_event_paranoid=2 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.perf_event_paranoid = 2",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_perf_event_paranoid",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_perf_event_paranoid",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.perf_event_paranoid from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.perf_event_paranoid.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.perf_event_paranoid\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl confi"
  },
  {
    "id": "openscap_134",
    "title": "Disable Access to Network bpf() Syscall From Unprivileged Processes",
    "description": "To set the runtime status of the kernel.unprivileged_bpf_disabled kernel parameter, run the following command: $ sudo sysctl -w kernel.unprivileged_bpf_disabled=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.unprivileged_bpf_disabled = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_unprivileged_bpf_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_unprivileged_bpf_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.unprivileged_bpf_disabled from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.unprivileged_bpf_disabled.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.unprivileged_bpf_disabled\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # "
  },
  {
    "id": "openscap_135",
    "title": "Restrict usage of ptrace to descendant processes",
    "description": "To set the runtime status of the kernel.yama.ptrace_scope kernel parameter, run the following command: $ sudo sysctl -w kernel.yama.ptrace_scope=1 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.yama.ptrace_scope = 1",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_yama_ptrace_scope",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_yama_ptrace_scope",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.yama.ptrace_scope from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.yama.ptrace_scope.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.yama.ptrace_scope\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config file"
  },
  {
    "id": "openscap_136",
    "title": "Harden the operation of the BPF just-in-time compiler",
    "description": "To set the runtime status of the net.core.bpf_jit_harden kernel parameter, run the following command: $ sudo sysctl -w net.core.bpf_jit_harden=2 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: net.core.bpf_jit_harden = 2",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_net_core_bpf_jit_harden",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_net_core_bpf_jit_harden",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of net.core.bpf_jit_harden from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*net.core.bpf_jit_harden.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"net.core.bpf_jit_harden\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config file wh"
  },
  {
    "id": "openscap_137",
    "title": "Disable the use of user namespaces",
    "description": "To set the runtime status of the user.max_user_namespaces kernel parameter, run the following command: $ sudo sysctl -w user.max_user_namespaces=0 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: user.max_user_namespaces = 0 When containers are deployed on the machine, the value should be set to large non-zero value.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_user_max_user_namespaces_no_remediation",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_user_max_user_namespaces_no_remediation",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Disable the use of user namespaces"
  },
  {
    "id": "openscap_138",
    "title": "Disable acquiring, saving, and processing core dumps",
    "description": "The systemd-coredump.socket unit is a socket activation of the systemd-coredump@.service which processes core dumps. By masking the unit, core dump processing is disabled.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_systemd-coredump_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_systemd-coredump_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then SOCKET_NAME=\"systemd-coredump.socket\" SYSTEMCTL_EXEC='/usr/bin/systemctl' if \"$SYSTEMCTL_EXEC\" -q list-unit-files --type socket | grep -q \"$SOCKET_NAME\"; then if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" stop \"$SOCKET_NAME\" fi \"$SYSTEMCTL_EXEC\" mask \"$SOCKET_NAME\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_139",
    "title": "Disable core dump backtraces",
    "description": "The ProcessSizeMax option in [Coredump] section of /etc/systemd/coredump.conf or in a drop-in file under /etc/systemd/coredump.conf.d/ specifies the maximum size in bytes of a core which will be processed. Core dumps exceeding this size may be stored, but the backtrace will not be generated.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_coredump_disable_backtraces",
    "rule": "xccdf_org.ssgproject.content_rule_coredump_disable_backtraces",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q systemd; }; then found=false # set value in all files if they contain section or key for f in $(echo -n \"/etc/systemd/coredump.conf.d/complianceascode_hardening.conf /etc/systemd/coredump.conf.d/*.conf /etc/systemd/coredump.conf\"); do if [ ! -e \"$f\" ]; then continue fi # find key in section and change value if grep -qzosP \"[[:space:]]*\\[Coredump\\]([^\\n\\[]*\\n+)+?[[:space:]]*ProcessSizeMax\" \"$f\"; then if ! grep -qPz \"ProcessSizeMax=0\" \"$f\"; then sed -i \"s/ProcessSizeMax[^(\\n)]*/ProcessSizeMax=0/\" \"$f\" fi found=true # find section and add key = value to it elif grep -qs \"[[:space:]]*\\[Coredump\\]\" \"$f\"; then sed -i \"/[[:space:]]*\\[Coredump\\]/a ProcessSizeMax=0\" \"$f\" found=true fi done # if s"
  },
  {
    "id": "openscap_140",
    "title": "Disable storing core dump",
    "description": "The Storage option in [Coredump] section of /etc/systemd/coredump.conf or a drop-in file in /etc/systemd/coredump.conf.d/*.conf can be set to none to disable storing core dumps permanently.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_coredump_disable_storage",
    "rule": "xccdf_org.ssgproject.content_rule_coredump_disable_storage",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q systemd; }; then found=false # set value in all files if they contain section or key for f in $(echo -n \"/etc/systemd/coredump.conf.d/complianceascode_hardening.conf /etc/systemd/coredump.conf.d/*.conf /etc/systemd/coredump.conf\"); do if [ ! -e \"$f\" ]; then continue fi # find key in section and change value if grep -qzosP \"[[:space:]]*\\[Coredump\\]([^\\n\\[]*\\n+)+?[[:space:]]*Storage\" \"$f\"; then if ! grep -qPz \"Storage=none\" \"$f\"; then sed -i \"s/Storage[^(\\n)]*/Storage=none/\" \"$f\" fi found=true # find section and add key = value to it elif grep -qs \"[[:space:]]*\\[Coredump\\]\" \"$f\"; then sed -i \"/[[:space:]]*\\[Coredump\\]/a Storage=none\" \"$f\" found=true fi done # if section not in any file, ap"
  },
  {
    "id": "openscap_141",
    "title": "Disable Core Dumps for All Users",
    "description": "To disable core dumps for all users, add the following line to /etc/security/limits.conf, or to a file within the /etc/security/limits.d/ directory: * hard core 0",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_disable_users_coredumps",
    "rule": "xccdf_org.ssgproject.content_rule_disable_users_coredumps",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q pam; }; then SECURITY_LIMITS_FILE=\"/etc/security/limits.conf\" DROPIN_DIR=\"/etc/security/limits.d\" DROPIN_FILE=\"$DROPIN_DIR/10-ssg-hardening.conf\" REGEX_CORRECT_VALUE=\"^\\s*\\*\\s+hard\\s+core\\s+0\\s*$\" # Remove bad configuration in drop-ins if [ -d \"$DROPIN_DIR\" ]; then for override in \"$DROPIN_DIR\"/*.conf; do if [ -f \"$override\" ] && ! grep -qE \"$REGEX_CORRECT_VALUE\" \"$override\"; then sed -ir -E '/^[[:space:]]*\\*[[:space:]]+hard[[:space:]]+core[[:space:]]+/ s/^/#/' \"$override\" fi done fi if [ -d \"$DROPIN_DIR\" ] && grep -qEr \"$REGEX_CORRECT_VALUE\" \"$DROPIN_DIR\"; then exit 0 elif [ ! -d \"$DROPIN_DIR\" ] && grep -qE \"$REGEX_CORRECT_VALUE\" \"$SECURITY_LIMITS_FILE\"; then exit 0 else mkdir -p \"$DROP"
  },
  {
    "id": "openscap_142",
    "title": "Enable Randomized Layout of Virtual Address Space",
    "description": "To set the runtime status of the kernel.randomize_va_space kernel parameter, run the following command: $ sudo sysctl -w kernel.randomize_va_space=2 To make sure that the setting is persistent, add the following line to a file in the directory /etc/sysctl.d: kernel.randomize_va_space = 2",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space",
    "rule": "xccdf_org.ssgproject.content_rule_sysctl_kernel_randomize_va_space",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then # Comment out any occurrences of kernel.randomize_va_space from /etc/sysctl.d/*.conf files for f in /etc/sysctl.d/*.conf /run/sysctl.d/*.conf /usr/local/lib/sysctl.d/*.conf; do # skip systemd-sysctl symlink (/etc/sysctl.d/99-sysctl.conf -> /etc/sysctl.conf) if [[ \"$(readlink -f \"$f\")\" == \"/etc/sysctl.conf\" ]]; then continue; fi matching_list=$(grep -P '^(?!#).*[\\s]*kernel.randomize_va_space.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do escaped_entry=$(sed -e 's|/|\\\\/|g' <<< \"$entry\") # comment out \"kernel.randomize_va_space\" matches to preserve user data sed -i --follow-symlinks \"s/^${escaped_entry}$/# &/g\" $f done <<< \"$matching_list\" fi done # # Set sysctl config f"
  },
  {
    "id": "openscap_143",
    "title": "Enable page allocator poisoning",
    "description": "To enable poisoning of free pages, add the argument page_poison=1 to the default GRUB 2 command line for the Linux operating system. To ensure that page_poison=1 is added as a kernel command line argument to newly installed kernels, add page_poison=1 to the default Grub2 command line for Linux operating systems. Modify the line within /etc/default/grub as shown below: GRUB_CMDLINE_LINUX=\"... page_poison=1 ...\" Run the following command to update command line for already installed kernels:# grubby --update-kernel=ALL --args=\"page_poison=1\" If the system is distributed as a bootable container image, GRUB2 can't be configured using the method described above, but the following method needs to be used instead. The kernel arguments should be set in /usr/lib/bootc/kargs.d in a TOML file that has the following form: # /usr/lib/bootc/kargs.d/10-example.toml kargs = [\"page_poison=1\"] For more details on configuring kernel arguments in bootable container images, please refer to Bootc documentation.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_page_poison_argument",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_page_poison_argument",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q grub2-common; }; then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then KARGS_DIR=\"/usr/lib/bootc/kargs.d/\" if grep -q -E \"page_poison\" \"$KARGS_DIR/*.toml\" ; then sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"page_poison=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"page_poison=1\\\"\\2/\" \"$KARGS_DIR/*.toml\" else echo \"kargs = [\\\"page_poison=1\\\"]\" >> \"$KARGS_DIR/10-page_poison.toml\" fi else grubby --update-kernel=ALL --args=page_poison=1 fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_144",
    "title": "Elevate The SELinux Context When An Administrator Calls The Sudo Command",
    "description": "Configure the operating system to elevate the SELinux context when an administrator calls the sudo command. Edit a file in the /etc/sudoers.d directory with the following command: sudo visudo -f /etc/sudoers.d/CUSTOM_FILE Use the following example to build the CUSTOM_FILE in the /etc/sudoers.d directory to allow any administrator belonging to a designated sudoers admin group to elevate their SELinux context with the use of the sudo command: %wheel ALL=(ALL) TYPE=sysadm_t ROLE=sysadm_r ALL",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_selinux_context_elevation_for_sudo",
    "rule": "xccdf_org.ssgproject.content_rule_selinux_context_elevation_for_sudo",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Elevate The SELinux Context When An Administrator Calls The Sudo Command"
  },
  {
    "id": "openscap_145",
    "title": "Disable KDump Kernel Crash Analyzer (kdump)",
    "description": "The kdump service provides a kernel crash dump analyzer. It uses the kexec system call to boot a secondary kernel (\"capture\" kernel) following a system crash, which can load information from the crashed kernel for analysis. The kdump service can be disabled with the following command: $ sudo systemctl mask --now kdump.service",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_kdump_disabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_kdump_disabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then SYSTEMCTL_EXEC='/usr/bin/systemctl' if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" stop 'kdump.service' fi \"$SYSTEMCTL_EXEC\" disable 'kdump.service' \"$SYSTEMCTL_EXEC\" mask 'kdump.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" -q list-unit-files kdump.socket; then if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" stop 'kdump.socket' fi \"$SYSTEMCTL_EXEC\" mask 'kdump.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed "
  },
  {
    "id": "openscap_146",
    "title": "Verify Permissions on cron.d",
    "description": "To properly set the permissions of /etc/cron.d, run the command: $ sudo chmod 0700 /etc/cron.d",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_cron_d",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_cron_d",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -H /etc/cron.d/ -maxdepth 0 -perm /u+s,g+xwrs,o+xwrt -type d -exec chmod u-s,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_147",
    "title": "Verify Permissions on cron.daily",
    "description": "To properly set the permissions of /etc/cron.daily, run the command: $ sudo chmod 0700 /etc/cron.daily",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_cron_daily",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_cron_daily",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -H /etc/cron.daily/ -maxdepth 0 -perm /u+s,g+xwrs,o+xwrt -type d -exec chmod u-s,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_148",
    "title": "Verify Permissions on cron.hourly",
    "description": "To properly set the permissions of /etc/cron.hourly, run the command: $ sudo chmod 0700 /etc/cron.hourly",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_cron_hourly",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_cron_hourly",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -H /etc/cron.hourly/ -maxdepth 0 -perm /u+s,g+xwrs,o+xwrt -type d -exec chmod u-s,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_149",
    "title": "Verify Permissions on cron.monthly",
    "description": "To properly set the permissions of /etc/cron.monthly, run the command: $ sudo chmod 0700 /etc/cron.monthly",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_cron_monthly",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_cron_monthly",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -H /etc/cron.monthly/ -maxdepth 0 -perm /u+s,g+xwrs,o+xwrt -type d -exec chmod u-s,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_150",
    "title": "Verify Permissions on cron.weekly",
    "description": "To properly set the permissions of /etc/cron.weekly, run the command: $ sudo chmod 0700 /etc/cron.weekly",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_cron_weekly",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_cron_weekly",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -H /etc/cron.weekly/ -maxdepth 0 -perm /u+s,g+xwrs,o+xwrt -type d -exec chmod u-s,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_151",
    "title": "Install fapolicyd Package",
    "description": "The fapolicyd package can be installed with the following command: $ sudo dnf install fapolicyd",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_fapolicyd_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_fapolicyd_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"fapolicyd\" ; then dnf install -y \"fapolicyd\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_152",
    "title": "Enable the File Access Policy Service",
    "description": "The File Access Policy service should be enabled. The fapolicyd service can be enabled with the following command: $ sudo systemctl enable fapolicyd.service",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_fapolicyd_enabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_fapolicyd_enabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'fapolicyd.service' if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" start 'fapolicyd.service' fi \"$SYSTEMCTL_EXEC\" enable 'fapolicyd.service' else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_153",
    "title": "Configure Fapolicy Module to Employ a Deny-all, Permit-by-exception Policy to Allow the Execution of Authorized Software Programs.",
    "description": "The Fapolicy module must be configured to employ a deny-all, permit-by-exception policy to allow the execution of authorized software programs and to prevent unauthorized software from running.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_fapolicy_default_deny",
    "rule": "xccdf_org.ssgproject.content_rule_fapolicy_default_deny",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then cat > /etc/fapolicyd/rules.d/99-deny-everything.rules << EOF # Red Hat KCS 7003854 (https://access.redhat.com/solutions/7003854) deny perm=any all : all EOF chmod 644 /etc/fapolicyd/rules.d/99-deny-everything.rules chgrp fapolicyd /etc/fapolicyd/rules.d/99-deny-everything.rules if [ -e \"/etc/fapolicyd/fapolicyd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*permissive\\s*=\\s*/Id\" \"/etc/fapolicyd/fapolicyd.conf\" else touch \"/etc/fapolicyd/fapolicyd.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/fapolicyd/fapolicyd.conf\" cp \"/etc/fapolicyd/fapolicyd.conf\" \"/etc/fapolicyd/fapolicyd.conf.bak\" # Insert at the end of the file printf '%s\\n' \"permissive = 0\" >> \"/etc/fapolicyd/fapolicyd.conf\" # C"
  },
  {
    "id": "openscap_154",
    "title": "The Postfix package is installed",
    "description": "A mail server is required for sending emails. The postfix package can be installed with the following command: $ sudo dnf install postfix",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_postfix_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_postfix_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"postfix\" ; then dnf install -y \"postfix\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_155",
    "title": "The s-nail Package Is Installed",
    "description": "A mail server is required for sending emails. The s-nail package can be installed with the following command: $ sudo dnf install s-nail",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_s-nail_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_s-nail_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"s-nail\" ; then dnf install -y \"s-nail\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_156",
    "title": "Configure System to Forward All Mail For The Root Account",
    "description": "Make sure that mails delivered to root user are forwarded to a monitored email address. Make sure that the address is a valid email address reachable from the system in question. Use the following command to configure the alias: $ sudo echo \"root: \" >> /etc/aliases $ sudo newaliases",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_postfix_client_configure_mail_alias",
    "rule": "xccdf_org.ssgproject.content_rule_postfix_client_configure_mail_alias",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_postfix_root_mail_alias='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^root\") # shellcheck disable=SC2059 printf -v formatted_output \"%s: %s\" \"$stripped_key\" \"$var_postfix_root_mail_alias\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^root\\\\>\" \"/etc/aliases\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --follow-symlinks \"s/^root\\\\"
  },
  {
    "id": "openscap_157",
    "title": "Disable chrony daemon from acting as server",
    "description": "The port option in /etc/chrony.conf can be set to 0 to make chrony daemon to never open any listening port for server operation and to operate strictly in a client-only mode.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_chronyd_client_only",
    "rule": "xccdf_org.ssgproject.content_rule_chronyd_client_only",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q chrony; }; then # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^port\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^port\\\\>\" \"/etc/chrony.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --follow-symlinks \"s/^port\\\\>.*/$escaped_formatted_ou"
  },
  {
    "id": "openscap_158",
    "title": "Disable network management of chrony daemon",
    "description": "The cmdport option in /etc/chrony.conf can be set to 0 to stop chrony daemon from listening on the UDP port 323 for management connections made by chronyc.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_chronyd_no_chronyc_network",
    "rule": "xccdf_org.ssgproject.content_rule_chronyd_no_chronyc_network",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q chrony; }; then # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^cmdport\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^cmdport\\\\>\" \"/etc/chrony.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\") LC_ALL=C sed -i --follow-symlinks \"s/^cmdport\\\\>.*/$escaped_for"
  },
  {
    "id": "openscap_159",
    "title": "Configure Time Service Maxpoll Interval",
    "description": "The maxpoll should be configured to in /etc/ntp.conf or /etc/chrony.conf (or /etc/chrony.d/) to continuously poll time servers. To configure maxpoll in /etc/ntp.conf or /etc/chrony.conf (or /etc/chrony.d/) add the following after each server, pool or peer entry: maxpoll to server directives. If using chrony, any pool directives should be configured too.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll",
    "rule": "xccdf_org.ssgproject.content_rule_chronyd_or_ntpd_set_maxpoll",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { ( rpm --quiet -q chrony || rpm --quiet -q ntp ); }; then var_time_service_set_maxpoll='' pof=\"/usr/sbin/pidof\" CONFIG_FILES=\"/etc/ntp.conf\" $pof ntpd || { CHRONY_D_PATH=/etc/chrony.d/ mapfile -t CONFIG_FILES < <(find ${CHRONY_D_PATH}.* -type f -name '*.conf') CONFIG_FILES+=(/etc/chrony.conf) } # get list of ntp files for config_file in \"${CONFIG_FILES[@]}\" ; do # Set maxpoll values to var_time_service_set_maxpoll sed -i \"s/^\\(\\(server\\|pool\\|peer\\).*maxpoll\\) [0-9,-][0-9]*\\(.*\\)$/\\1 $var_time_service_set_maxpoll \\3/\" \"$config_file\" done for config_file in \"${CONFIG_FILES[@]}\" ; do # Add maxpoll to server, pool or peer entries without maxpoll grep \"^\\(server\\|pool\\|peer\\)\" \"$config_file\" | grep -v maxpo"
  },
  {
    "id": "openscap_160",
    "title": "Ensure Chrony is only configured with the server directive",
    "description": "Check that Chrony only has time sources configured with the server directive.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_chronyd_server_directive",
    "rule": "xccdf_org.ssgproject.content_rule_chronyd_server_directive",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Ensure Chrony is only configured with the server directive"
  },
  {
    "id": "openscap_161",
    "title": "Verify Permissions on SSH Server Config File",
    "description": "To properly set the permissions of files in /etc/ssh/sshd_config.d, run the command: find -H /etc/ssh/sshd_config.d -type d -exec chown 0600 {} \\;",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_file_permissions_sshd_drop_in_config",
    "rule": "xccdf_org.ssgproject.content_rule_file_permissions_sshd_drop_in_config",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then find -P /etc/ssh/sshd_config.d/ -maxdepth 1 -perm /u+xs,g+xwrs,o+xwrt -type f -regextype posix-extended -regex '^.*$' -exec chmod u-xs,g-xwrs,o-xwrt {} \\; else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_162",
    "title": "Set SSH Client Alive Count Max",
    "description": "The SSH server sends at most ClientAliveCountMax messages during a SSH session and waits for a response from the SSH client. The option ClientAliveInterval configures timeout after each ClientAliveCountMax message. If the SSH server does not receive a response from the client, then the connection is considered unresponsive and terminated. For SSH earlier than v8.2, a ClientAliveCountMax value of 0 causes a timeout precisely when the ClientAliveInterval is set. Starting with v8.2, a value of 0 disables the timeout functionality completely. If the option is set to a number greater than 0, then the session will be disconnected after ClientAliveInterval * ClientAliveCountMax seconds without receiving a keep alive message.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_set_keepalive",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_set_keepalive",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_sshd_set_keepalive='' mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-har"
  },
  {
    "id": "openscap_163",
    "title": "Set SSH Client Alive Interval",
    "description": "SSH allows administrators to set a network responsiveness timeout interval. After this interval has passed, the unresponsive client will be automatically logged out. To set this timeout interval, edit the following line in /etc/ssh/sshd_config as follows: ClientAliveInterval The timeout interval is given in seconds. For example, have a timeout of 10 minutes, set interval to 600. If a shorter timeout has already been set for the login shell, that value will preempt any SSH setting made in /etc/ssh/sshd_config. Keep in mind that some processes may stop SSH from correctly detecting that the user is idle.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then sshd_idle_timeout_value='' mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-ha"
  },
  {
    "id": "openscap_164",
    "title": "Disable Host-Based Authentication",
    "description": "SSH's cryptographic host-based authentication is more secure than .rhosts authentication. However, it is not recommended that hosts unilaterally trust one another, even within an organization. The default SSH configuration disables host-based authentication. The appropriate configuration is used if no value is set for HostbasedAuthentication. To explicitly disable host-based authentication, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: HostbasedAuthentication no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_disable_host_auth",
    "rule": "xccdf_org.ssgproject.content_rule_disable_host_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*HostbasedAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*HostbasedAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*HostbasedAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \""
  },
  {
    "id": "openscap_165",
    "title": "Disable Compression Or Set Compression to delayed",
    "description": "Compression is useful for slow network connections over long distances but can cause performance issues on local LANs. If use of compression is required, it should be enabled only after a user has authenticated; otherwise, it should be disabled. To disable compression or delay compression until after a user has successfully authenticated, add or correct the following line in the /etc/ssh/sshd_config file: Compression",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_compression",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_compression",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_sshd_disable_compression='' mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*Compression\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*Compression\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Compression\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/"
  },
  {
    "id": "openscap_166",
    "title": "Disable SSH Access via Empty Passwords",
    "description": "Disallow SSH login with empty passwords. The default SSH configuration disables logins with empty passwords. The appropriate configuration is used if no value is set for PermitEmptyPasswords. To explicitly disallow SSH login from accounts with empty passwords, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: PermitEmptyPasswords no Any accounts with empty passwords should be disabled immediately, and PAM configuration should prevent users from being able to assign themselves empty passwords.",
    "severity": "3",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_empty_passwords",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/"
  },
  {
    "id": "openscap_167",
    "title": "Disable GSSAPI Authentication",
    "description": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like GSSAPI. The default SSH configuration disallows authentications based on GSSAPI. The appropriate configuration is used if no value is set for GSSAPIAuthentication. To explicitly disable GSSAPI authentication, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: GSSAPIAuthentication no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_gssapi_auth",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_gssapi_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/"
  },
  {
    "id": "openscap_168",
    "title": "Disable Kerberos Authentication",
    "description": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like Kerberos. The default SSH configuration disallows authentication validation through Kerberos. The appropriate configuration is used if no value is set for KerberosAuthentication. To explicitly disable Kerberos authentication, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: KerberosAuthentication no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_kerb_auth",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_kerb_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*KerberosAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*KerberosAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*KerberosAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/et"
  },
  {
    "id": "openscap_169",
    "title": "Disable SSH Support for .rhosts Files",
    "description": "SSH can emulate the behavior of the obsolete rsh command in allowing users to enable insecure access to their accounts via .rhosts files. The default SSH configuration disables support for .rhosts. The appropriate configuration is used if no value is set for IgnoreRhosts. To explicitly disable support for .rhosts files, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: IgnoreRhosts yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_rhosts",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_rhosts",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*IgnoreRhosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*IgnoreRhosts\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreRhosts\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complia"
  },
  {
    "id": "openscap_170",
    "title": "Disable SSH Root Login",
    "description": "The root user should never be allowed to login to a system directly over a network. To disable root login via SSH, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: PermitRootLogin no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_root_login",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_root_login",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/etc/ssh/sshd_config."
  },
  {
    "id": "openscap_171",
    "title": "Disable SSH Support for User Known Hosts",
    "description": "SSH can allow system users to connect to systems if a cache of the remote systems public keys is available. This should be disabled. To ensure this behavior is disabled, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: IgnoreUserKnownHosts yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_user_known_hosts",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_user_known_hosts",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*IgnoreUserKnownHosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*IgnoreUserKnownHosts\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreUserKnownHosts\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/etc/s"
  },
  {
    "id": "openscap_172",
    "title": "Disable X11 Forwarding",
    "description": "The X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections. SSH has the capability to encrypt remote X11 connections when SSH's X11Forwarding option is enabled. The default SSH configuration disables X11Forwarding. The appropriate configuration is used if no value is set for X11Forwarding. To explicitly disable X11 Forwarding, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: X11Forwarding no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_disable_x11_forwarding",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-comp"
  },
  {
    "id": "openscap_173",
    "title": "Do Not Allow SSH Environment Options",
    "description": "Ensure that users are not able to override environment variables of the SSH daemon. The default SSH configuration disables environment processing. The appropriate configuration is used if no value is set for PermitUserEnvironment. To explicitly disable Environment options, add or correct the following /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: PermitUserEnvironment no",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_do_not_permit_user_env",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/s"
  },
  {
    "id": "openscap_174",
    "title": "Enable Public Key Authentication",
    "description": "Enable SSH login with public keys. The default SSH configuration enables authentication based on public keys. The appropriate configuration is used if no value is set for PubkeyAuthentication. To explicitly enable Public Key Authentication, add or correct the following /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: PubkeyAuthentication yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_enable_pubkey_auth",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/etc/s"
  },
  {
    "id": "openscap_175",
    "title": "Enable Use of Strict Mode Checking",
    "description": "SSHs StrictModes option checks file and ownership permissions in the user's home directory .ssh folder before accepting login. If world- writable permissions are found, logon is rejected. The default SSH configuration has StrictModes enabled. The appropriate configuration is used if no value is set for StrictModes. To explicitly enable StrictModes in SSH, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: StrictModes yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_enable_strictmodes",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_enable_strictmodes",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*StrictModes\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*StrictModes\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*StrictModes\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-compliance"
  },
  {
    "id": "openscap_176",
    "title": "Enable SSH Warning Banner",
    "description": "To enable the warning banner and ensure it is consistent across the system, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: Banner /etc/issue Another section contains information on how to create an appropriate system-wide warning banner.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_enable_warning_banner",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/etc/ssh/sshd_config.d/00-complianceascode-harde"
  },
  {
    "id": "openscap_177",
    "title": "Enable SSH Print Last Log",
    "description": "Ensure that SSH will display the date and time of the last successful account logon. The default SSH configuration enables print of the date and time of the last login. The appropriate configuration is used if no value is set for PrintLastLog. To explicitly enable LastLog in SSH, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: PrintLastLog yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_print_last_log",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_print_last_log",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*PrintLastLog\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*PrintLastLog\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*PrintLastLog\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/01-complia"
  },
  {
    "id": "openscap_178",
    "title": "Force frequent session key renegotiation",
    "description": "The RekeyLimit parameter specifies how often the session key of the is renegotiated, both in terms of amount of data that may be transmitted and the time elapsed. To decrease the default limits, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: RekeyLimit",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_rekey_limit",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_rekey_limit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then var_rekey_limit_size='' var_rekey_limit_time='' mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*RekeyLimit\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*RekeyLimit\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*RekeyLimit\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardenin"
  },
  {
    "id": "openscap_179",
    "title": "Set SSH Daemon LogLevel to VERBOSE",
    "description": "The VERBOSE parameter configures the SSH daemon to record login and logout activity. To specify the log level in SSH, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: LogLevel VERBOSE",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_set_loglevel_verbose",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_set_loglevel_verbose",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf chmod 0600 /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" else touch \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf\" cp \"/etc/ssh/sshd_config.d/00-complianceascode"
  },
  {
    "id": "openscap_180",
    "title": "Prevent remote hosts from connecting to the proxy display",
    "description": "The SSH daemon should prevent remote hosts from connecting to the proxy display. The default SSH configuration for X11UseLocalhost is yes, which prevents remote hosts from connecting to the proxy display. To explicitly prevent remote connections to the proxy display, add or correct the following line in /etc/ssh/sshd_config.d/00-complianceascode-hardening.conf: X11UseLocalhost yes",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost",
    "rule": "xccdf_org.ssgproject.content_rule_sshd_x11_use_localhost",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then mkdir -p /etc/ssh/sshd_config.d touch /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf chmod 0600 /etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config\" LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d\"/*.conf if [ -e \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" else touch \"/etc/ssh/sshd_config.d/01-complianceascode-reinforce-os-defaults.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/ssh/sshd_config.d/0"
  },
  {
    "id": "openscap_181",
    "title": "Certificate status checking in SSSD",
    "description": "Multifactor solutions that require devices separate from information systems gaining access include, for example, hardware tokens providing time-based or challenge-response authenticators and smart cards. Configuring certificate_verification to ocsp_dgst= ensures that certificates for multifactor solutions are checked via Online Certificate Status Protocol (OCSP).",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sssd_certificate_verification",
    "rule": "xccdf_org.ssgproject.content_rule_sssd_certificate_verification",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q sssd-common; then var_sssd_certificate_verification_digest_function='' # sssd configuration files must be created with 600 permissions if they don't exist # otherwise the sssd module fails to start OLD_UMASK=$(umask) umask u=rw,go= MAIN_CONF=\"/etc/sssd/conf.d/certificate_verification.conf\" found=false # set value in all files if they contain section or key for f in $(echo -n \"$MAIN_CONF /etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\"); do if [ ! -e \"$f\" ]; then continue fi # find key in section and change value if grep -qzosP \"[[:space:]]*\\[sssd\\]([^\\n\\[]*\\n+)+?[[:space:]]*certificate_verification\" \"$f\"; then if ! grep -qPz \"certificate_verification=ocsp_dgst=$var_sssd_certificate_verification_digest_function\" \"$f\"; then "
  },
  {
    "id": "openscap_182",
    "title": "Enable Certmap in SSSD",
    "description": "SSSD should be configured to verify the certificate of the user or group. To set this up ensure that section like certmap/testing.test/rule_name is setup in /etc/sssd/sssd.conf. For example [certmap/testing.test/rule_name] matchrule =<SAN>.*EDIPI@mil maprule = (userCertificate;binary={cert!bin}) domains = testing.test",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sssd_enable_certmap",
    "rule": "xccdf_org.ssgproject.content_rule_sssd_enable_certmap",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Review and remediate: Enable Certmap in SSSD"
  },
  {
    "id": "openscap_183",
    "title": "Enable Smartcards in SSSD",
    "description": "SSSD should be configured to authenticate access to the system using smart cards. To enable smart cards in SSSD, set pam_cert_auth to True under the [pam] section in /etc/sssd/sssd.conf. For example: [pam] pam_cert_auth = True Add or update \"pam_sss.so\" line in auth section of \"/etc/pam.d/system-auth\" file to include \"try_cert_auth\" or \"require_cert_auth\" option, like in the following example: /etc/pam.d/system-auth:auth [success=done authinfo_unavail=ignore ignore=ignore default=die] pam_sss.so try_cert_auth Also add or update \"pam_sss.so\" line in auth section of \"/etc/pam.d/smartcard-auth\" file to include the \"allow_missing_name\" option, like in the following example: /etc/pam.d/smartcard-auth:auth sufficient pam_sss.so allow_missing_name",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_sssd_enable_smartcards",
    "rule": "xccdf_org.ssgproject.content_rule_sssd_enable_smartcards",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q sssd-common; then # sssd configuration files must be created with 600 permissions if they don't exist # otherwise the sssd module fails to start OLD_UMASK=$(umask) umask u=rw,go= found=false # set value in all files if they contain section or key for f in $(echo -n \"/etc/sssd/sssd.conf /etc/sssd/conf.d/*.conf\"); do if [ ! -e \"$f\" ]; then continue fi # find key in section and change value if grep -qzosP \"[[:space:]]*\\[pam\\]([^\\n\\[]*\\n+)+?[[:space:]]*pam_cert_auth\" \"$f\"; then if ! grep -qPz \"pam_cert_auth=True\" \"$f\"; then sed -i \"s/pam_cert_auth[^(\\n)]*/pam_cert_auth=True/\" \"$f\" fi found=true # find section and add key = value to it elif grep -qs \"[[:space:]]*\\[pam\\]\" \"$f\"; then sed -i \"/[[:space:]]*\\[pam\\]/a pam_cert_au"
  },
  {
    "id": "openscap_184",
    "title": "Install usbguard Package",
    "description": "The usbguard package can be installed with the following command: $ sudo dnf install usbguard",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_usbguard_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_usbguard_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ) && rpm --quiet -q kernel-core ); then if ! rpm -q --quiet \"usbguard\" ; then dnf install -y \"usbguard\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_185",
    "title": "Enable the USBGuard Service",
    "description": "The USBGuard service should be enabled. The usbguard service can be enabled with the following command: $ sudo systemctl enable usbguard.service",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_service_usbguard_enabled",
    "rule": "xccdf_org.ssgproject.content_rule_service_usbguard_enabled",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ) && rpm --quiet -q kernel-core ); then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'usbguard.service' if [[ $(\"$SYSTEMCTL_EXEC\" is-system-running) != \"offline\" ]]; then \"$SYSTEMCTL_EXEC\" start 'usbguard.service' fi \"$SYSTEMCTL_EXEC\" enable 'usbguard.service' else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_186",
    "title": "Generate USBGuard Policy",
    "description": "By default USBGuard when enabled prevents access to all USB devices and this lead to inaccessible system if they use USB mouse/keyboard. To prevent this scenario, the initial policy configuration must be generated based on current connected USB devices.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_usbguard_generate_policy",
    "rule": "xccdf_org.ssgproject.content_rule_usbguard_generate_policy",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if ( ! ( grep -sqE \"^.*\\.s390x$\" /proc/sys/kernel/osrelease || grep -sqE \"^s390x$\" /proc/sys/kernel/arch; ) && rpm --quiet -q kernel-core ); then if rpm --quiet -q usbguard then USBGUARD_CONF=/etc/usbguard/rules.conf if [ ! -f \"$USBGUARD_CONF\" ] || [ ! -s \"$USBGUARD_CONF\" ]; then usbguard generate-policy > $USBGUARD_CONF if [ ! -s \"$USBGUARD_CONF\" ]; then # make sure OVAL check doesn't fail on systems where # generate-policy doesn't find any USB devices (for # example a system might not have a USB bus) echo \"# No USB devices found\" > $USBGUARD_CONF fi # make sure it has correct permissions chmod 600 $USBGUARD_CONF SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'usbguard.service' \"$SYSTEMCTL_EXEC\" restart 'usbguard.service'"
  },
  {
    "id": "openscap_187",
    "title": "Install audispd-plugins Package",
    "description": "The audispd-plugins package can be installed with the following command: $ sudo dnf install audispd-plugins",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_package_audispd-plugins_installed",
    "rule": "xccdf_org.ssgproject.content_rule_package_audispd-plugins_installed",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core; then if ! rpm -q --quiet \"audispd-plugins\" ; then dnf install -y \"audispd-plugins\" fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_188",
    "title": "Enable Auditing for Processes Which Start Prior to the Audit Daemon",
    "description": "To ensure all processes can be audited, even those which start prior to the audit daemon, add the argument audit=1 to the default GRUB 2 command line for the Linux operating system. To ensure that audit=1 is added as a kernel command line argument to newly installed kernels, add audit=1 to the default Grub2 command line for Linux operating systems. Modify the line within /etc/default/grub as shown below: GRUB_CMDLINE_LINUX=\"... audit=1 ...\" Run the following command to update command line for already installed kernels:# grubby --update-kernel=ALL --args=\"audit=1\" If the system is distributed as a bootable container image, GRUB2 can't be configured using the method described above, but the following method needs to be used instead. The kernel arguments should be set in /usr/lib/bootc/kargs.d in a TOML file that has the following form: # /usr/lib/bootc/kargs.d/10-example.toml kargs = [\"audit=1\"] For more details on configuring kernel arguments in bootable container images, please refer to Bootc documentation.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_audit_argument",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_audit_argument",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q grub2-common; }; then if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then KARGS_DIR=\"/usr/lib/bootc/kargs.d/\" if grep -q -E \"audit\" \"$KARGS_DIR/*.toml\" ; then sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"audit=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"audit=1\\\"\\2/\" \"$KARGS_DIR/*.toml\" else echo \"kargs = [\\\"audit=1\\\"]\" >> \"$KARGS_DIR/10-audit.toml\" fi else grubby --update-kernel=ALL --args=audit=1 fi else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_189",
    "title": "Extend Audit Backlog Limit for the Audit Daemon",
    "description": "To improve the kernel capacity to queue all log events, even those which occurred prior to the audit daemon, add the argument audit_backlog_limit= to the default GRUB 2 command line for the Linux operating system. To ensure that audit_backlog_limit= is added as a kernel command line argument to newly installed kernels, add audit_backlog_limit= to the default Grub2 command line for Linux operating systems. Modify the line within /etc/default/grub as shown below: GRUB_CMDLINE_LINUX=\"... audit_backlog_limit= ...\" Run the following command to update command line for already installed kernels:# grubby --update-kernel=ALL --args=\"audit_backlog_limit=\" If the system is distributed as a bootable container image, GRUB2 can't be configured using the method described above, but the following method needs to be used instead. The kernel arguments should be set in /usr/lib/bootc/kargs.d in a TOML file that has the following form: # /usr/lib/bootc/kargs.d/10-example.toml kargs = [\"audit_backlog_limit=\"] For more details on configuring kernel arguments in bootable container images, please refer to Bootc documentation.",
    "severity": "1",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_grub2_audit_backlog_limit_argument",
    "rule": "xccdf_org.ssgproject.content_rule_grub2_audit_backlog_limit_argument",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q kernel-core && { rpm --quiet -q grub2-common; }; then var_audit_backlog_limit='' if { rpm --quiet -q kernel rpm-ostree bootc && ! rpm --quiet -q openshift-kubelet && { [ -f \"/run/.containerenv\" ] || [ -f \"/.containerenv\" ]; }; } ; then KARGS_DIR=\"/usr/lib/bootc/kargs.d/\" if grep -q -E \"audit_backlog_limit\" \"$KARGS_DIR/*.toml\" ; then sed -i -E \"s/^(\\s*kargs\\s*=\\s*\\[.*)\\\"audit_backlog_limit=[^\\\"]*\\\"(.*]\\s*)/\\1\\\"audit_backlog_limit=$var_audit_backlog_limit\\\"\\2/\" \"$KARGS_DIR/*.toml\" else echo \"kargs = [\\\"audit_backlog_limit=$var_audit_backlog_limit\\\"]\" >> \"$KARGS_DIR/10-audit_backlog_limit.toml\" fi else grubby --update-kernel=ALL --args=audit_backlog_limit=$var_audit_backlog_limit fi else >&2 echo 'Remediation is not appli"
  },
  {
    "id": "openscap_190",
    "title": "Ensure auditd Collects Changes to Cron Jobs - /etc/cron.d/",
    "description": "At a minimum, the audit system should collect administrator actions for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/cron.d/ -p wa -k cronjobs If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/cron.d/ -p wa -k cronjobs",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_etc_cron_d",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_etc_cron_d",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_191",
    "title": "Make the auditd Configuration Immutable",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d in order to make the auditd configuration immutable: -e 2 If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file in order to make the auditd configuration immutable: -e 2 With this setting, a reboot will be required to change any audit rules.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_immutable",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_immutable",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Traverse all of: # # /etc/audit/audit.rules, (for auditctl case) # /etc/audit/rules.d/*.rules (for augenrules case) # # files to check if '-e .*' setting is present in that '*.rules' file already. # If found, delete such occurrence since auditctl(8) manual page instructs the # '-e 2' rule should be placed as the last rule in the configuration find /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-e[[:space:]]\\+.*/d' {} ';' # Append '-e 2' requirement at the end of both: # * /etc/audit/audit.rules file (for auditctl case) # * /etc/audit/rules.d/immutable.rules (for augenrules case) for AUDIT_FILE in \"/etc/audit/audit.rules\" \"/etc/audit/rules.d/i"
  },
  {
    "id": "openscap_192",
    "title": "Ensure auditd Collects System Administrator Actions - /etc/sudoers",
    "description": "At a minimum, the audit system should collect administrator actions for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/sudoers -p wa -k actions If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/sudoers -p wa -k actions",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_sudoers",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_sudoers",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_193",
    "title": "Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/",
    "description": "At a minimum, the audit system should collect administrator actions for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/sudoers.d/ -p wa -k actions If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/sudoers.d/ -p wa -k actions",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_sudoers_d",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_sudoers_d",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_194",
    "title": "Record Events When Privileged Executables Are Run",
    "description": "Verify the system generates an audit record when privileged functions are executed. If audit is using the \"auditctl\" tool to load the rules, run the following command: $ sudo grep execve /etc/audit/audit.rules If audit is using the \"augenrules\" tool to load the rules, run the following command: $ sudo grep -r execve /etc/audit/rules.d -a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid -a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid -a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid -a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid If both the \"b32\" and \"b64\" audit rules for \"SUID\" files are not defined, this is a finding. If both the \"b32\" and \"b64\" audit rules for \"SGID\" files are not defined, this is a finding.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_suid_privilege_function",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"-C uid!=euid -F euid=0\" AUID_FILTERS=\"\" SYSCALL=\"execve\" KEY=\"setuid\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arr"
  },
  {
    "id": "openscap_195",
    "title": "Shutdown System When Auditing Failures Occur",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to to the bottom of a file with suffix .rules in the directory /etc/audit/rules.d: -f If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to the bottom of the /etc/audit/audit.rules file: -f",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_system_shutdown",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_system_shutdown",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_audit_failure_mode='' # Traverse all of: # # /etc/audit/audit.rules, (for auditctl case) # /etc/audit/rules.d/*.rules (for augenrules case) find /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-f[[:space:]]\\+.*/d' {} ';' for AUDIT_FILE in \"/etc/audit/audit.rules\" \"/etc/audit/rules.d/immutable.rules\" do echo '' >> $AUDIT_FILE echo '# Set the audit.rules configuration to halt system upon audit failure per security requirements' >> $AUDIT_FILE echo \"-f $var_audit_failure_mode\" >> $AUDIT_FILE done else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_196",
    "title": "Record Events that Modify User/Group Information - /etc/group",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/group -p wa -k audit_rules_usergroup_modification If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/group -p wa -k audit_rules_usergroup_modification",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_197",
    "title": "Record Events that Modify User/Group Information - /etc/gshadow",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_198",
    "title": "Record Events that Modify User/Group Information - /etc/security/opasswd",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_199",
    "title": "Record Events that Modify User/Group Information - /etc/passwd",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/passwd -p wa -k audit_rules_usergroup_modification If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/passwd -p wa -k audit_rules_usergroup_modification",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_200",
    "title": "Record Events that Modify User/Group Information - /etc/shadow",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /etc/shadow -p wa -k audit_rules_usergroup_modification If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /etc/shadow -p wa -k audit_rules_usergroup_modification",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_201",
    "title": "Ensure auditd Collects Changes to Cron Jobs - /var/spool/cron",
    "description": "If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /var/spool/cron -p wa -k cronjobs If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /var/spool/cron -p wa -k cronjobs",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_var_spool_cron",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_var_spool_cron",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_202",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fchmod",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fchmod -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchmod -F auid>=1000 -F auid!=unset -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fchmod -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchmod -F auid>=1000 -F auid!=unset -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fchmod\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"chmod fchmod fchmodat\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # "
  },
  {
    "id": "openscap_203",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fchmodat",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchmodat -F auid>=1000 -F auid!=unset -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fchmodat\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"chmod fchmod fchmodat\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule "
  },
  {
    "id": "openscap_204",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fchown",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fchown -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchown -F auid>=1000 -F auid!=unset -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fchown -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchown -F auid>=1000 -F auid!=unset -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fchown\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"chown fchown fchownat lchown\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_"
  },
  {
    "id": "openscap_205",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fchownat",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fchownat -F auid>=1000 -F auid!=unset -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fchownat\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"chown fchown fchownat lchown\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset ful"
  },
  {
    "id": "openscap_206",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fremovexattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fremovexattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unse"
  },
  {
    "id": "openscap_207",
    "title": "Record Events that Modify the System's Discretionary Access Controls - fsetxattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S fsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S fsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S fsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"fsetxattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset o"
  },
  {
    "id": "openscap_208",
    "title": "Record Events that Modify the System's Discretionary Access Controls - lremovexattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S lremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S lremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S lremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S lremovexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"lremovexattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unse"
  },
  {
    "id": "openscap_209",
    "title": "Record Events that Modify the System's Discretionary Access Controls - lsetxattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S lsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S lsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S lsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S lsetxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"lsetxattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset o"
  },
  {
    "id": "openscap_210",
    "title": "Record Events that Modify the System's Discretionary Access Controls - removexattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S removexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S removexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S removexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S removexattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"removexattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset"
  },
  {
    "id": "openscap_211",
    "title": "Record Events that Modify the System's Discretionary Access Controls - setxattr",
    "description": "At a minimum, the audit system should collect file permission changes for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S setxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S setxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S setxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S setxattr -F auid>=1000 -F auid!=unset -F key=perm_mod -a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"setxattr\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset ot"
  },
  {
    "id": "openscap_212",
    "title": "Record Events that Modify the System's Discretionary Access Controls - umount2",
    "description": "At a minimum, the audit system should collect file system umount2 changes. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S umount2 -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S umount2 -F auid>=1000 -F auid!=unset -F key=perm_mod If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S umount2 -F auid>=1000 -F auid!=unset -F key=perm_mod If the system is 64 bit then also add the following line: -a always,exit -F arch=b64 -S umount2 -F auid>=1000 -F auid!=unset -F key=perm_mod",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_umount2",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_umount2",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"umount2\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments"
  },
  {
    "id": "openscap_213",
    "title": "Record Any Attempts to Run chacl",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/chacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chacl",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/chacl -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected f"
  },
  {
    "id": "openscap_214",
    "title": "Record Any Attempts to Run setfacl",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfacl",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/setfacl -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected"
  },
  {
    "id": "openscap_215",
    "title": "Record Any Attempts to Run chcon",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/chcon -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_chcon",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/chcon -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected f"
  },
  {
    "id": "openscap_216",
    "title": "Record Any Attempts to Run semanage",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_semanage",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_semanage",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/semanage -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_217",
    "title": "Record Any Attempts to Run setfiles",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/setfiles -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/setfiles -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfiles",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setfiles",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/setfiles -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_218",
    "title": "Record Any Attempts to Run setsebool",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setsebool",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_execution_setsebool",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/setsebool -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspec"
  },
  {
    "id": "openscap_219",
    "title": "Ensure auditd Collects File Deletion Events by User - renameat",
    "description": "At a minimum, the audit system should collect file deletion events for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S renameat -F auid>=1000 -F auid!=unset -F key=delete If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S renameat -F auid>=1000 -F auid!=unset -F key=delete",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"renameat\" KEY=\"delete\" SYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid"
  },
  {
    "id": "openscap_220",
    "title": "Ensure auditd Collects File Deletion Events by User - unlinkat",
    "description": "At a minimum, the audit system should collect file deletion events for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following line to a file with suffix .rules in the directory /etc/audit/rules.d, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S unlinkat -F auid>=1000 -F auid!=unset -F key=delete If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following line to /etc/audit/audit.rules file, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S unlinkat -F auid>=1000 -F auid!=unset -F key=delete",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"unlinkat\" KEY=\"delete\" SYSCALL_GROUPING=\"unlink unlinkat rename renameat renameat2 rmdir\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid"
  },
  {
    "id": "openscap_221",
    "title": "Record Unsuccessful Access Attempts to Files - ftruncate",
    "description": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"ftruncate\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"-F exit=-EACCES\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset "
  },
  {
    "id": "openscap_222",
    "title": "Record Unsuccessful Access Attempts to Files - open_by_handle_at",
    "description": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"open_by_handle_at\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"-F exit=-EACCES\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edi"
  },
  {
    "id": "openscap_223",
    "title": "Record Unsuccessful Access Attempts to Files - openat",
    "description": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"openat\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"-F exit=-EACCES\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset oth"
  },
  {
    "id": "openscap_224",
    "title": "Record Unsuccessful Access Attempts to Files - truncate",
    "description": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules file: -a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access If the system is 64 bit then also add the following lines: -a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access -a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"truncate\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"-F exit=-EACCES\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset o"
  },
  {
    "id": "openscap_225",
    "title": "Ensure auditd Collects Information on Kernel Module Unloading - delete_module",
    "description": "To capture kernel module loading and unloading events, use the following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S delete_module -F auid>=1000 -F auid!=unset -F key=modules Place to add the line depends on a way auditd daemon is configured. If it is configured to use the augenrules program (the default), add the line to a file with suffix .rules in the directory /etc/audit/rules.d. If the auditd daemon is configured to use the auditctl utility, add the line to file /etc/audit/audit.rules.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up => # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"delete_module\" KEY=\"modules\" SYSCALL_GROUPING=\"create_module delete_module finit_module init_module query_mo"
  },
  {
    "id": "openscap_226",
    "title": "Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module",
    "description": "To capture kernel module loading and unloading events, use the following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S finit_module -F auid>=1000 -F auid!=unset -F key=modules Place to add the line depends on a way auditd daemon is configured. If it is configured to use the augenrules program (the default), add the line to a file with suffix .rules in the directory /etc/audit/rules.d. If the auditd daemon is configured to use the auditctl utility, add the line to file /etc/audit/audit.rules.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up => # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"finit_module\" KEY=\"modules\" SYSCALL_GROUPING=\"create_module delete_module finit_module init_module query_mod"
  },
  {
    "id": "openscap_227",
    "title": "Ensure auditd Collects Information on Kernel Module Loading - init_module",
    "description": "To capture kernel module loading and unloading events, use the following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit: -a always,exit -F arch=ARCH -S init_module -F auid>=1000 -F auid!=unset -F key=modules Place to add the line depends on a way auditd daemon is configured. If it is configured to use the augenrules program (the default), add the line to a file with suffix .rules in the directory /etc/audit/rules.d. If the auditd daemon is configured to use the auditctl utility, add the line to file /etc/audit/audit.rules.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up => # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"init_module\" KEY=\"modules\" SYSCALL_GROUPING=\"create_module delete_module finit_module init_module query_modu"
  },
  {
    "id": "openscap_228",
    "title": "Record Attempts to Alter Logon and Logout Events - faillock",
    "description": "The audit system already collects login information for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w -p wa -k logins If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w -p wa -k logins",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillock",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_faillock",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' var_accounts_passwords_pam_faillock_dir='' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # -------------------------------------------------------------------------------------"
  },
  {
    "id": "openscap_229",
    "title": "Record Attempts to Alter Logon and Logout Events - lastlog",
    "description": "The audit system already collects login information for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /var/log/lastlog -p wa -k logins If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /var/log/lastlog -p wa -k logins",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_lastlog",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_230",
    "title": "Record Attempts to Alter Logon and Logout Events - tallylog",
    "description": "The audit system already collects login information for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix .rules in the directory /etc/audit/rules.d: -w /var/log/tallylog -p wa -k logins If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules: -w /var/log/tallylog -p wa -k logins",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_tallylog",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_login_events_tallylog",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules."
  },
  {
    "id": "openscap_231",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - init",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/init -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/init -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_init",
    "rule": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_init",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/init -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected f"
  },
  {
    "id": "openscap_232",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - poweroff",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/poweroff -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/poweroff -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_poweroff",
    "rule": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_poweroff",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/poweroff -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_233",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - reboot",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/reboot -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/reboot -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_reboot",
    "rule": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_reboot",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/reboot -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected"
  },
  {
    "id": "openscap_234",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - shutdown",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/shutdown -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/shutdown -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_shutdown",
    "rule": "xccdf_org.ssgproject.content_rule_audit_privileged_commands_shutdown",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/shutdown -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_235",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - chage",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chage",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/chage -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected f"
  },
  {
    "id": "openscap_236",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - chsh",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_chsh",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/chsh -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected fo"
  },
  {
    "id": "openscap_237",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - crontab",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_crontab",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/crontab -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected"
  },
  {
    "id": "openscap_238",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_gpasswd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/gpasswd -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected"
  },
  {
    "id": "openscap_239",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - kmod",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/kmod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_kmod",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/kmod -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected fo"
  },
  {
    "id": "openscap_240",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - mount",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_mount",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/mount -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected f"
  },
  {
    "id": "openscap_241",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - newgrp",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_newgrp",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/newgrp -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected "
  },
  {
    "id": "openscap_242",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_pam_timestamp_check",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/pam_timestamp_check -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should"
  },
  {
    "id": "openscap_243",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - passwd",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_passwd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/passwd -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected "
  },
  {
    "id": "openscap_244",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - postdrop",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_postdrop",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_postdrop",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/postdrop -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_245",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - postqueue",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_postqueue",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_postqueue",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/postqueue -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspec"
  },
  {
    "id": "openscap_246",
    "title": "Record Any Attempts to Run ssh-agent",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_agent",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/ssh-agent -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspect"
  },
  {
    "id": "openscap_247",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_ssh_keysign",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/libexec/openssh/ssh-keysign -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that sho"
  },
  {
    "id": "openscap_248",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - su",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_su",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/su -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for "
  },
  {
    "id": "openscap_249",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - sudo",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudo",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/sudo -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected fo"
  },
  {
    "id": "openscap_250",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_sudoedit",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/sudoedit -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspecte"
  },
  {
    "id": "openscap_251",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - umount",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_umount",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/bin/umount -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected "
  },
  {
    "id": "openscap_252",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_chkpwd",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_chkpwd",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_chkpwd",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/unix_chkpwd -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be insp"
  },
  {
    "id": "openscap_253",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_update",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_unix_update",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/unix_update -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be insp"
  },
  {
    "id": "openscap_254",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - userhelper",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_userhelper",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_userhelper",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/userhelper -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspe"
  },
  {
    "id": "openscap_255",
    "title": "Ensure auditd Collects Information on the Use of Privileged Commands - usermod",
    "description": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add a line of the following form to a file with suffix .rules in the directory /etc/audit/rules.d: -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add a line of the following form to /etc/audit/audit.rules: -a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid>=1000 -F auid!=unset -F key=privileged",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod",
    "rule": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands_usermod",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then # Retrieve hardware architecture of the underlying system OTHER_FILTERS=\"-F path=/usr/sbin/usermod -F perm=x\" AUID_FILTERS=\"-F auid>=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" ACTION_ARCH_FILTERS=\"-a always,exit\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' unset syscall_a unset syscall_grouping unset syscall_string unset syscall unset file_to_edit unset rule_to_edit unset rule_syscalls_to_edit unset other_string unset auid_string unset full_rule # Load macro arguments into arrays read -a syscall_a <<< $SYSCALL read -a syscall_grouping <<< $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspecte"
  },
  {
    "id": "openscap_256",
    "title": "Configure auditd Disk Error Action on Disk Error",
    "description": "The auditd service can be configured to take an action when there is a disk error. Edit the file /etc/audit/auditd.conf. Add or modify the following line, substituting ACTION appropriately: disk_error_action = ACTION Set this value to single to cause the system to switch to single-user mode for corrective action. Acceptable values also include syslog, exec, single, and halt. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values for ACTION are described in the auditd.conf man page.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_disk_error_action_stig",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_disk_error_action_stig",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_disk_error_action='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^disk_error_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_disk_error_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^disk_error_action\\\\>\" \"/etc/audit/auditd.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$"
  },
  {
    "id": "openscap_257",
    "title": "Configure auditd Disk Full Action when Disk Space Is Full",
    "description": "The auditd service can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file /etc/audit/auditd.conf. Add or modify the following line, substituting ACTION appropriately: disk_full_action = ACTION Set this value to single to cause the system to switch to single-user mode for corrective action. Acceptable values also include syslog, single, and halt. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values for ACTION are described in the auditd.conf man page.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action_stig",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_disk_full_action_stig",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_disk_full_action='' # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^disk_full_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_disk_full_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^disk_full_action\\\\>\" \"/etc/audit/auditd.conf\"; then escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$form"
  },
  {
    "id": "openscap_258",
    "title": "Configure auditd admin_space_left Action on Low Disk Space",
    "description": "The auditd service can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file /etc/audit/auditd.conf. Add or modify the following line, substituting ACTION appropriately: admin_space_left_action = ACTION Set this value to single to cause the system to switch to single user mode for corrective action. Acceptable values also include suspend and halt. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values for ACTION are described in the auditd.conf man page.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_admin_space_left_action='' var_auditd_admin_space_left_action=\"$(echo $var_auditd_admin_space_left_action | cut -d \\| -f 1)\" AUDITCONFIG=/etc/audit/auditd.conf # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^admin_space_left_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_admin_space_left_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\>), # so if we search for 'setting', 'setting2' "
  },
  {
    "id": "openscap_259",
    "title": "Configure auditd admin_space_left on Low Disk Space",
    "description": "The auditd service can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file /etc/audit/auditd.conf. Add or modify the following line, substituting PERCENTAGE appropriately: admin_space_left = PERCENTAGE% Set this value to to cause the system to perform an action.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_percentage",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_percentage",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_admin_space_left_percentage='' grep -q \"^admin_space_left[[:space:]]*=.*$\" /etc/audit/auditd.conf && \\ sed -i \"s/^admin_space_left[[:space:]]*=.*$/admin_space_left = $var_auditd_admin_space_left_percentage%/g\" /etc/audit/auditd.conf || \\ echo \"admin_space_left = $var_auditd_admin_space_left_percentage%\" >> /etc/audit/auditd.conf else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_260",
    "title": "Configure auditd space_left Action on Low Disk Space",
    "description": "The auditd service can be configured to take an action when disk space starts to run low. Edit the file /etc/audit/auditd.conf. Modify the following line, substituting ACTION appropriately: space_left_action = ACTION Possible values for ACTION are described in the auditd.conf man page. These include: syslogemailexecsuspendsinglehalt Set this to email (instead of the default, which is suspend) as it is more likely to get prompt attention. Acceptable values also include suspend, single, and halt.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_space_left_action='' var_auditd_space_left_action=\"$(echo $var_auditd_space_left_action | cut -d \\| -f 1)\" # # If space_left_action present in /etc/audit/auditd.conf, change value # to var_auditd_space_left_action, else # add \"space_left_action = $var_auditd_space_left_action\" to /etc/audit/auditd.conf # AUDITCONFIG=/etc/audit/auditd.conf # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^space_left_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_space_left_action\" # If the key exists, "
  },
  {
    "id": "openscap_261",
    "title": "Configure auditd space_left on Low Disk Space",
    "description": "The auditd service can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file /etc/audit/auditd.conf. Add or modify the following line, substituting PERCENTAGE appropriately: space_left = PERCENTAGE% Set this value to at least 25 to cause the system to notify the user of an issue.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_percentage",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_space_left_percentage='' grep -q \"^space_left[[:space:]]*=.*$\" /etc/audit/auditd.conf && \\ sed -i \"s/^space_left[[:space:]]*=.*$/space_left = $var_auditd_space_left_percentage%/g\" /etc/audit/auditd.conf || \\ echo \"space_left = $var_auditd_space_left_percentage%\" >> /etc/audit/auditd.conf else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_262",
    "title": "Set number of records to cause an explicit flush to audit logs",
    "description": "To configure Audit daemon to issue an explicit flush to disk command after writing records, set freq to in /etc/audit/auditd.conf.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_freq",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_freq",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_freq='' if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*freq\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/audit/auditd.conf\" cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s\\n' \"freq = $var_auditd_freq\" >> \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  },
  {
    "id": "openscap_263",
    "title": "Set type of computer node name logging in audit logs",
    "description": "To configure Audit daemon to use a unique identifier as computer node name in the audit events, set name_format to in /etc/audit/auditd.conf.",
    "severity": "2",
    "result": "fail",
    "oval_id": "xccdf_org.ssgproject.content_rule_auditd_name_format",
    "rule": "xccdf_org.ssgproject.content_rule_auditd_name_format",
    "class": "compliance",
    "host": "localhost",
    "os": "localhost.localdomain",
    "recommendation": "Remediation script: # Remediation is applicable only in certain platforms if rpm --quiet -q audit && rpm --quiet -q kernel-core; then var_auditd_name_format='' var_auditd_name_format=\"$(echo $var_auditd_name_format | cut -d \\| -f 1)\" if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*name_format\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi # make sure file has newline at the end sed -i -e '$a\\' \"/etc/audit/auditd.conf\" cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s\\n' \"name_format = $var_auditd_name_format\" >> \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else >&2 echo 'Remediation is not applicable, nothing was done' fi"
  }
]